#pragma version 10
#pragma typetrack false


main:
    intcblock 1 0 32 2
    bytecblock 0x151f7c75 "boxMap" 0x00 "boxInt" 0x00010203 "boxString" "boxDynamicBytes" "users" "42" 0x0003 "boxRef"


    txn NumAppArgs
    bz main_bare_routing@31
    pushbytess 0xb7491344 0x49cf4105 0x6ab3e9bc 0x26ca648a 0x28cc7139 0x644a3994 0xb1f5a9b6 0x03e8c77e 0xd829d2a3 0x8c22bfd5 0xfa1562f7 0xc497bc6f 0xf4f9cbad 0x9e11fd7a 0x5e6ceac0 0xf53418c4 0x39e9b226 0x9101a7de 0xa4552eb5 0x38acf53e 0x8600e0eb 0x799689d5 0x156ef28d 0xb2d39fea 0x0a4036cd 0x547f0a74
    txna ApplicationArgs 0
    match main_getBox_route@3 main_valueBox_route@4 main_maybeBox_route@5 main_getBoxMap_route@6 main_getBoxMapWithDefault_route@7 main_maybeBoxMap_route@8 main_keyPrefixBoxMap_route@9 main_getBoxRef_route@10 main_boxMapExists_route@11 main_maybeBoxRef_route@12 main_setBox_route@13 main_setBoxString_route@14 main_setBoxDynamicBytes_route@15 main_setBoxMap_route@16 main_setBoxRef_route@17 main_boxMapLength_route@18 main_lengthBoxRef_route@19 main_deleteBox_route@20 main_deleteBoxMap_route@21 main_deleteBoxRef_route@22 main_extractBoxRef_route@23 main_getBoxMapObject_route@24 main_boxMapObjectExists_route@25 main_setBoxMapObject_route@26 main_boxMapObjectLength_route@27 main_arc4Box_route@28

main_after_if_else@35:
    err

main_arc4Box_route@28:


    txn OnCompletion
    !
    assert
    txn ApplicationID
    assert


    txna ApplicationArgs 1
    extract 2 0


    callsub arc4Box
    bytec_0
    swap
    concat
    log
    intc_0
    return

main_boxMapObjectLength_route@27:


    txn OnCompletion
    !
    assert
    txn ApplicationID
    assert


    txna ApplicationArgs 1
    btoi


    callsub boxMapObjectLength
    itob
    bytec_0
    swap
    concat
    log
    intc_0
    return

main_setBoxMapObject_route@26:


    txn OnCompletion
    !
    assert
    txn ApplicationID
    assert


    txna ApplicationArgs 1
    btoi
    txna ApplicationArgs 2


    callsub setBoxMapObject
    bytec_2
    intc_1
    uncover 2
    setbit
    bytec_0
    swap
    concat
    log
    intc_0
    return

main_boxMapObjectExists_route@25:


    txn OnCompletion
    !
    assert
    txn ApplicationID
    assert


    txna ApplicationArgs 1
    btoi


    callsub boxMapObjectExists
    bytec_2
    intc_1
    uncover 2
    setbit
    bytec_0
    swap
    concat
    log
    intc_0
    return

main_getBoxMapObject_route@24:


    txn OnCompletion
    !
    assert
    txn ApplicationID
    assert


    txna ApplicationArgs 1
    btoi


    callsub getBoxMapObject
    bytec_0
    swap
    concat
    log
    intc_0
    return

main_extractBoxRef_route@23:


    txn OnCompletion
    !
    assert
    txn ApplicationID
    assert


    txna ApplicationArgs 1
    extract 2 0


    callsub extractBoxRef
    intc_0
    return

main_deleteBoxRef_route@22:


    txn OnCompletion
    !
    assert
    txn ApplicationID
    assert


    txna ApplicationArgs 1
    extract 2 0


    callsub deleteBoxRef
    intc_0
    return

main_deleteBoxMap_route@21:


    txn OnCompletion
    !
    assert
    txn ApplicationID
    assert


    txna ApplicationArgs 1
    btoi


    callsub deleteBoxMap
    intc_0
    return

main_deleteBox_route@20:


    txn OnCompletion
    !
    assert
    txn ApplicationID
    assert
    callsub deleteBox
    intc_0
    return

main_lengthBoxRef_route@19:


    txn OnCompletion
    !
    assert
    txn ApplicationID
    assert


    txna ApplicationArgs 1
    extract 2 0


    callsub lengthBoxRef
    itob
    bytec_0
    swap
    concat
    log
    intc_0
    return

main_boxMapLength_route@18:


    txn OnCompletion
    !
    assert
    txn ApplicationID
    assert


    txna ApplicationArgs 1
    btoi


    callsub boxMapLength
    itob
    bytec_0
    swap
    concat
    log
    intc_0
    return

main_setBoxRef_route@17:


    txn OnCompletion
    !
    assert
    txn ApplicationID
    assert


    txna ApplicationArgs 1
    extract 2 0


    callsub setBoxRef
    intc_0
    return

main_setBoxMap_route@16:


    txn OnCompletion
    !
    assert
    txn ApplicationID
    assert


    txna ApplicationArgs 1
    btoi
    txna ApplicationArgs 2
    extract 2 0


    callsub setBoxMap
    intc_0
    return

main_setBoxDynamicBytes_route@15:


    txn OnCompletion
    !
    assert
    txn ApplicationID
    assert


    txna ApplicationArgs 1


    callsub setBoxDynamicBytes
    intc_0
    return

main_setBoxString_route@14:


    txn OnCompletion
    !
    assert
    txn ApplicationID
    assert


    txna ApplicationArgs 1
    extract 2 0


    callsub setBoxString
    intc_0
    return

main_setBox_route@13:


    txn OnCompletion
    !
    assert
    txn ApplicationID
    assert


    txna ApplicationArgs 1
    btoi


    callsub setBox
    intc_0
    return

main_maybeBoxRef_route@12:


    txn OnCompletion
    !
    assert
    txn ApplicationID
    assert


    txna ApplicationArgs 1
    extract 2 0


    callsub maybeBoxRef
    bytec_0
    swap
    concat
    log
    intc_0
    return

main_boxMapExists_route@11:


    txn OnCompletion
    !
    assert
    txn ApplicationID
    assert


    txna ApplicationArgs 1
    btoi


    callsub boxMapExists
    bytec_2
    intc_1
    uncover 2
    setbit
    bytec_0
    swap
    concat
    log
    intc_0
    return

main_getBoxRef_route@10:


    txn OnCompletion
    !
    assert
    txn ApplicationID
    assert
    callsub getBoxRef
    bytec_0
    swap
    concat
    log
    intc_0
    return

main_keyPrefixBoxMap_route@9:


    txn OnCompletion
    !
    assert
    txn ApplicationID
    assert
    pushbytes 0x151f7c750006626f784d6170
    log
    intc_0
    return

main_maybeBoxMap_route@8:


    txn OnCompletion
    !
    assert
    txn ApplicationID
    assert


    txna ApplicationArgs 1
    btoi


    callsub maybeBoxMap
    bytec_0
    swap
    concat
    log
    intc_0
    return

main_getBoxMapWithDefault_route@7:


    txn OnCompletion
    !
    assert
    txn ApplicationID
    assert


    txna ApplicationArgs 1
    btoi


    callsub getBoxMapWithDefault
    dup
    len
    itob
    extract 6 2
    swap
    concat
    bytec_0
    swap
    concat
    log
    intc_0
    return

main_getBoxMap_route@6:


    txn OnCompletion
    !
    assert
    txn ApplicationID
    assert


    txna ApplicationArgs 1
    btoi


    callsub getBoxMap
    dup
    len
    itob
    extract 6 2
    swap
    concat
    bytec_0
    swap
    concat
    log
    intc_0
    return

main_maybeBox_route@5:


    txn OnCompletion
    !
    assert
    txn ApplicationID
    assert
    callsub maybeBox
    bytec_0
    swap
    concat
    log
    intc_0
    return

main_valueBox_route@4:


    txn OnCompletion
    !
    assert
    txn ApplicationID
    assert
    callsub valueBox
    itob
    bytec_0
    swap
    concat
    log
    intc_0
    return

main_getBox_route@3:


    txn OnCompletion
    !
    assert
    txn ApplicationID
    assert
    callsub getBox
    itob
    bytec_0
    swap
    concat
    log
    intc_0
    return

main_bare_routing@31:


    txn OnCompletion
    bnz main_after_if_else@35
    txn ApplicationID
    !
    assert
    intc_0
    return



getBox:


    bytec_3


    box_get
    assert
    btoi
    retsub



valueBox:


    bytec_3


    box_get
    assert
    btoi
    retsub



maybeBox:


    bytec_3


    box_get
    swap
    btoi


    itob
    bytec_2
    intc_1
    uncover 3
    setbit
    concat
    retsub



getBoxMap:



    proto 1 1


    frame_dig -1
    itob


    bytec_1
    swap
    concat


    box_get
    assert
    retsub



getBoxMapWithDefault:



    proto 1 1


    frame_dig -1
    itob


    bytec_1
    swap
    concat


    box_get
    pushbytes "default"
    cover 2
    select
    retsub



maybeBoxMap:



    proto 1 1


    frame_dig -1
    itob


    bytec_1
    swap
    concat


    box_get
    dup
    uncover 2
    swap


    bz maybeBoxMap_ternary_false@2
    frame_dig 1

maybeBoxMap_ternary_merge@3:


    dup
    len
    itob
    extract 6 2
    swap
    concat
    bytec_2
    intc_1
    frame_dig 0
    setbit
    bytec 9
    swap
    concat
    swap
    concat
    frame_bury 0
    retsub

maybeBoxMap_ternary_false@2:


    pushbytes ""
    b maybeBoxMap_ternary_merge@3



getBoxRef:


    bytec 10


    intc_2
    box_create
    pop


    txn Sender


    dup


    bytec 10


    dig 1
    box_put


    dup
    uncover 2
    ==
    assert


    retsub



boxMapExists:



    proto 1 1


    frame_dig -1
    itob


    bytec_1
    swap
    concat


    box_len
    bury 1
    retsub



maybeBoxRef:



    proto 1 1


    frame_dig -1
    box_get


    dig 1
    len
    itob
    extract 6 2
    uncover 2
    concat
    bytec_2
    intc_1
    uncover 3
    setbit
    bytec 9
    swap
    concat
    swap
    concat
    retsub



setBox:


    proto 1 0


    frame_dig -1
    itob


    bytec_3


    swap
    box_put
    retsub



setBoxString:


    proto 1 0


    bytec 5


    box_del
    pop


    bytec 5


    frame_dig -1
    box_put
    retsub



setBoxDynamicBytes:


    proto 1 0


    bytec 6


    box_del
    pop


    bytec 6


    frame_dig -1
    box_put
    retsub



setBoxMap:


    proto 2 0


    frame_dig -2
    itob


    bytec_1
    swap
    concat


    dup
    box_del
    pop
    frame_dig -1
    box_put
    retsub



setBoxRef:


    proto 1 0


    frame_dig -1
    intc_2
    box_create
    pop


    frame_dig -1


    txn Sender


    box_put
    retsub



boxMapLength:



    proto 1 1


    frame_dig -1
    itob


    bytec_1
    swap
    concat
    dup


    box_len
    bury 1
    bnz boxMapLength_after_if_else@2


    intc_1
    swap
    retsub

boxMapLength_after_if_else@2:


    frame_dig 0
    box_len
    assert
    swap
    retsub



lengthBoxRef:


    proto 1 1


    frame_dig -1
    intc_2
    box_create
    assert


    frame_dig -1
    box_len
    pop
    retsub



deleteBox:


    bytec_3


    box_del
    pop


    bytec 6


    box_del
    pop


    bytec 5


    box_del
    pop


    bytec_3


    box_get
    swap
    btoi
    pushint 42
    swap
    uncover 2
    select
    pushint 42
    ==
    assert


    bytec 6


    box_get
    pushbytes 0x00023432
    cover 2
    select
    extract 2 0
    bytec 8
    ==
    assert


    bytec 5


    box_get
    bytec 8
    cover 2
    select
    bytec 8
    ==
    assert
    retsub



deleteBoxMap:


    proto 1 0


    frame_dig -1
    itob


    bytec_1
    swap
    concat


    box_del
    pop
    retsub



deleteBoxRef:


    proto 1 0


    frame_dig -1
    box_del
    pop


    frame_dig -1
    box_get
    pop
    pushbytes ""
    ==
    intc_0
    &&
    frame_dig -1
    box_len
    bury 1
    !
    &&
    assert
    retsub



extractBoxRef:


    proto 1 0


    txn Sender


    global CurrentApplicationAddress


    frame_dig -1


    pushint 64


    box_create
    assert


    frame_dig -1
    intc_1
    dig 3
    box_replace


    frame_dig -1
    intc_1
    dup
    dig 3
    box_splice


    frame_dig -1
    intc_1
    intc_2
    box_extract


    frame_dig -1
    intc_2
    dup
    box_extract


    swap
    uncover 2
    ==
    assert


    ==
    assert
    retsub



getBoxMapObject:



    proto 1 1


    frame_dig -1
    itob


    bytec 7
    swap
    concat


    box_get
    assert
    retsub



boxMapObjectExists:



    proto 1 1


    frame_dig -1
    itob


    bytec 7
    swap
    concat


    box_len
    bury 1
    retsub



setBoxMapObject:


    proto 2 1


    frame_dig -2
    itob


    bytec 7
    swap
    concat


    dup
    box_del
    pop
    dup
    frame_dig -1
    box_put










    dup
    intc_3
    pushint 8
    box_extract
    btoi


    frame_dig -1
    intc_3
    extract_uint64










    ==
    intc_0
    &&
    swap
    pushints 10 8
    box_extract
    btoi


    frame_dig -1
    pushint 10
    extract_uint64










    ==
    &&
    assert


    intc_0
    retsub



boxMapObjectLength:


    proto 1 1


    frame_dig -1
    itob


    bytec 7
    swap
    concat


    dup
    box_del
    pop
    dup
    pushbytes 0x0012000000000000004600000000000004d20008746573744e616d65
    box_put


    box_len
    pop
    retsub



arc4Box:


    proto 1 1


    frame_dig -1
    bytec 4
    box_put
    bytec 4


    intc_1
    getbyte
    !
    assert


    bytec 4


    intc_0
    getbyte
    intc_0
    ==
    assert


    bytec 4


    intc_3
    getbyte
    intc_3
    ==
    assert


    bytec 4


    pushint 3
    getbyte
    pushint 3
    ==
    assert


    bytec 4


    retsub
