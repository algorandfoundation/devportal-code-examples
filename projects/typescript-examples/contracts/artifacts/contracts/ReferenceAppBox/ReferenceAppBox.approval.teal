#pragma version 11
#pragma typetrack false

// @algorandfoundation/algorand-typescript/arc4/index.d.ts::Contract.approvalProgram() -> uint64:
main:
    intcblock 1 0 8 400
    bytecblock "keyLength" "boxMbr" "counter" 0x151f7c75 "valueLength" "boxSize"
    txn ApplicationID
    bnz main_after_if_else@2
    // contracts/ReferenceAppBox/contract.algo.ts:25
    // public keyLength = GlobalState<uint64>({ initialValue: Uint64(32 + 19) }) // Account address (32 bytes) + key prefix overhead (19 bytes)
    bytec_0 // "keyLength"
    pushint 51 // 51
    app_global_put
    // contracts/ReferenceAppBox/contract.algo.ts:26
    // public valueLength = GlobalState<uint64>({ initialValue: Uint64(8) }) // uint64 (8 bytes)
    bytec 4 // "valueLength"
    intc_2 // 8
    app_global_put
    // contracts/ReferenceAppBox/contract.algo.ts:39
    // this.boxSize.value = this.keyLength.value + this.valueLength.value
    intc_1 // 0
    // contracts/ReferenceAppBox/contract.algo.ts:25
    // public keyLength = GlobalState<uint64>({ initialValue: Uint64(32 + 19) }) // Account address (32 bytes) + key prefix overhead (19 bytes)
    bytec_0 // "keyLength"
    // contracts/ReferenceAppBox/contract.algo.ts:39
    // this.boxSize.value = this.keyLength.value + this.valueLength.value
    app_global_get_ex
    assert // check GlobalState exists
    // contracts/ReferenceAppBox/contract.algo.ts:26
    // public valueLength = GlobalState<uint64>({ initialValue: Uint64(8) }) // uint64 (8 bytes)
    intc_2 // 8
    // contracts/ReferenceAppBox/contract.algo.ts:39
    // this.boxSize.value = this.keyLength.value + this.valueLength.value
    +
    // contracts/ReferenceAppBox/contract.algo.ts:27
    // public boxSize = GlobalState<uint64>() // Calculated in constructor
    bytec 5 // "boxSize"
    // contracts/ReferenceAppBox/contract.algo.ts:39
    // this.boxSize.value = this.keyLength.value + this.valueLength.value
    dig 1
    app_global_put
    // contracts/ReferenceAppBox/contract.algo.ts:40
    // this.boxMbr.value = Uint64(2500) + this.boxSize.value * Uint64(400) // Base MBR + (size * per-byte cost)
    intc_3 // 400
    *
    pushint 2500 // 2500
    +
    // contracts/ReferenceAppBox/contract.algo.ts:28
    // public boxMbr = GlobalState<uint64>() // Calculated in constructor
    bytec_1 // "boxMbr"
    // contracts/ReferenceAppBox/contract.algo.ts:40
    // this.boxMbr.value = Uint64(2500) + this.boxSize.value * Uint64(400) // Base MBR + (size * per-byte cost)
    swap
    app_global_put

main_after_if_else@2:
    // contracts/ReferenceAppBox/contract.algo.ts:22-23
    // @contract({ stateTotals: { globalUints: 4 } })
    // export default class ReferenceAppBox extends Contract {
    txn NumAppArgs
    bz main___algots__.defaultCreate@15
    txn OnCompletion
    !
    assert // OnCompletion must be NoOp
    txn ApplicationID
    assert
    pushbytess 0x040a235e 0x5425a145 0xe924e5e0 0xbbb5239e 0x1aefe7f5 0x0e385162 // method "incrementBoxCounter(pay)uint64", method "getBoxCounter()uint64", method "getBoxCounterForAccount(address)uint64", method "getBoxMbr()uint64", method "getBoxConfiguration()(uint64,uint64,uint64,uint64)", method "updateBoxConfiguration(uint64,uint64)void"
    txna ApplicationArgs 0
    match incrementBoxCounter getBoxCounter getBoxCounterForAccount getBoxMbr getBoxConfiguration updateBoxConfiguration
    err

main___algots__.defaultCreate@15:
    // contracts/ReferenceAppBox/contract.algo.ts:22-23
    // @contract({ stateTotals: { globalUints: 4 } })
    // export default class ReferenceAppBox extends Contract {
    txn OnCompletion
    !
    txn ApplicationID
    !
    &&
    return // on error: OnCompletion must be NoOp && can only call when creating


// contracts/ReferenceAppBox/contract.algo.ts::ReferenceAppBox.incrementBoxCounter[routing]() -> void:
incrementBoxCounter:
    // contracts/ReferenceAppBox/contract.algo.ts:49
    // @abimethod()
    txn GroupIndex
    intc_0 // 1
    -
    dup
    gtxns TypeEnum
    intc_0 // pay
    ==
    assert // transaction type is pay
    // contracts/ReferenceAppBox/contract.algo.ts:52
    // assert(payMbr.amount === this.boxMbr.value, 'Payment must cover the box MBR')
    dup
    gtxns Amount
    intc_1 // 0
    // contracts/ReferenceAppBox/contract.algo.ts:28
    // public boxMbr = GlobalState<uint64>() // Calculated in constructor
    bytec_1 // "boxMbr"
    // contracts/ReferenceAppBox/contract.algo.ts:52
    // assert(payMbr.amount === this.boxMbr.value, 'Payment must cover the box MBR')
    app_global_get_ex
    assert // check GlobalState exists
    ==
    assert // Payment must cover the box MBR
    // contracts/ReferenceAppBox/contract.algo.ts:53
    // assert(payMbr.receiver === Global.currentApplicationAddress, 'Payment must be to the contract')
    gtxns Receiver
    global CurrentApplicationAddress
    ==
    assert // Payment must be to the contract
    // contracts/ReferenceAppBox/contract.algo.ts:31
    // public accountBoxCounter = BoxMap<Account, uint64>({ keyPrefix: 'counter' })
    bytec_2 // "counter"
    // contracts/ReferenceAppBox/contract.algo.ts:55
    // const [counter, hasCounter] = this.accountBoxCounter(Txn.sender).maybe()
    txn Sender
    // contracts/ReferenceAppBox/contract.algo.ts:31
    // public accountBoxCounter = BoxMap<Account, uint64>({ keyPrefix: 'counter' })
    concat
    // contracts/ReferenceAppBox/contract.algo.ts:55
    // const [counter, hasCounter] = this.accountBoxCounter(Txn.sender).maybe()
    box_get
    swap
    btoi
    swap
    // contracts/ReferenceAppBox/contract.algo.ts:57
    // if (hasCounter) {
    bz incrementBoxCounter_else_body@3
    // contracts/ReferenceAppBox/contract.algo.ts:59
    // this.accountBoxCounter(Txn.sender).value = counter + 1
    dup
    intc_0 // 1
    +
    // contracts/ReferenceAppBox/contract.algo.ts:31
    // public accountBoxCounter = BoxMap<Account, uint64>({ keyPrefix: 'counter' })
    bytec_2 // "counter"
    // contracts/ReferenceAppBox/contract.algo.ts:59
    // this.accountBoxCounter(Txn.sender).value = counter + 1
    txn Sender
    // contracts/ReferenceAppBox/contract.algo.ts:31
    // public accountBoxCounter = BoxMap<Account, uint64>({ keyPrefix: 'counter' })
    concat
    // contracts/ReferenceAppBox/contract.algo.ts:59
    // this.accountBoxCounter(Txn.sender).value = counter + 1
    dig 1
    itob
    box_put

incrementBoxCounter_after_inlined_contracts/ReferenceAppBox/contract.algo.ts::ReferenceAppBox.incrementBoxCounter@4:
    // contracts/ReferenceAppBox/contract.algo.ts:49
    // @abimethod()
    itob
    bytec_3 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return

incrementBoxCounter_else_body@3:
    // contracts/ReferenceAppBox/contract.algo.ts:31
    // public accountBoxCounter = BoxMap<Account, uint64>({ keyPrefix: 'counter' })
    bytec_2 // "counter"
    // contracts/ReferenceAppBox/contract.algo.ts:63
    // this.accountBoxCounter(Txn.sender).value = Uint64(1)
    txn Sender
    // contracts/ReferenceAppBox/contract.algo.ts:31
    // public accountBoxCounter = BoxMap<Account, uint64>({ keyPrefix: 'counter' })
    concat
    // contracts/ReferenceAppBox/contract.algo.ts:63
    // this.accountBoxCounter(Txn.sender).value = Uint64(1)
    intc_0 // 1
    itob
    box_put
    // contracts/ReferenceAppBox/contract.algo.ts:64
    // return Uint64(1)
    intc_0 // 1
    // contracts/ReferenceAppBox/contract.algo.ts:49
    // @abimethod()
    b incrementBoxCounter_after_inlined_contracts/ReferenceAppBox/contract.algo.ts::ReferenceAppBox.incrementBoxCounter@4


// contracts/ReferenceAppBox/contract.algo.ts::ReferenceAppBox.getBoxCounter[routing]() -> void:
getBoxCounter:
    // contracts/ReferenceAppBox/contract.algo.ts:31
    // public accountBoxCounter = BoxMap<Account, uint64>({ keyPrefix: 'counter' })
    bytec_2 // "counter"
    // contracts/ReferenceAppBox/contract.algo.ts:74
    // const [counter, hasCounter] = this.accountBoxCounter(Txn.sender).maybe()
    txn Sender
    // contracts/ReferenceAppBox/contract.algo.ts:31
    // public accountBoxCounter = BoxMap<Account, uint64>({ keyPrefix: 'counter' })
    concat
    // contracts/ReferenceAppBox/contract.algo.ts:74
    // const [counter, hasCounter] = this.accountBoxCounter(Txn.sender).maybe()
    box_get
    swap
    btoi
    swap
    // contracts/ReferenceAppBox/contract.algo.ts:76
    // if (hasCounter) {
    bz getBoxCounter_after_if_else@3
    dup

getBoxCounter_after_inlined_contracts/ReferenceAppBox/contract.algo.ts::ReferenceAppBox.getBoxCounter@4:
    // contracts/ReferenceAppBox/contract.algo.ts:72
    // @abimethod({ readonly: true })
    itob
    bytec_3 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return

getBoxCounter_after_if_else@3:
    // contracts/ReferenceAppBox/contract.algo.ts:80
    // return 0
    intc_1 // 0
    // contracts/ReferenceAppBox/contract.algo.ts:72
    // @abimethod({ readonly: true })
    b getBoxCounter_after_inlined_contracts/ReferenceAppBox/contract.algo.ts::ReferenceAppBox.getBoxCounter@4


// contracts/ReferenceAppBox/contract.algo.ts::ReferenceAppBox.getBoxCounterForAccount[routing]() -> void:
getBoxCounterForAccount:
    // contracts/ReferenceAppBox/contract.algo.ts:31
    // public accountBoxCounter = BoxMap<Account, uint64>({ keyPrefix: 'counter' })
    bytec_2 // "counter"
    // contracts/ReferenceAppBox/contract.algo.ts:88
    // @abimethod({ readonly: true })
    txna ApplicationArgs 1
    // contracts/ReferenceAppBox/contract.algo.ts:31
    // public accountBoxCounter = BoxMap<Account, uint64>({ keyPrefix: 'counter' })
    concat
    // contracts/ReferenceAppBox/contract.algo.ts:90
    // const [counter, hasCounter] = this.accountBoxCounter(account).maybe()
    box_get
    swap
    btoi
    swap
    // contracts/ReferenceAppBox/contract.algo.ts:92
    // if (hasCounter) {
    bz getBoxCounterForAccount_after_if_else@3
    dup

getBoxCounterForAccount_after_inlined_contracts/ReferenceAppBox/contract.algo.ts::ReferenceAppBox.getBoxCounterForAccount@4:
    // contracts/ReferenceAppBox/contract.algo.ts:88
    // @abimethod({ readonly: true })
    itob
    bytec_3 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return

getBoxCounterForAccount_after_if_else@3:
    // contracts/ReferenceAppBox/contract.algo.ts:96
    // return 0
    intc_1 // 0
    // contracts/ReferenceAppBox/contract.algo.ts:88
    // @abimethod({ readonly: true })
    b getBoxCounterForAccount_after_inlined_contracts/ReferenceAppBox/contract.algo.ts::ReferenceAppBox.getBoxCounterForAccount@4


// contracts/ReferenceAppBox/contract.algo.ts::ReferenceAppBox.getBoxMbr[routing]() -> void:
getBoxMbr:
    // contracts/ReferenceAppBox/contract.algo.ts:105
    // return this.boxMbr.value
    intc_1 // 0
    // contracts/ReferenceAppBox/contract.algo.ts:28
    // public boxMbr = GlobalState<uint64>() // Calculated in constructor
    bytec_1 // "boxMbr"
    // contracts/ReferenceAppBox/contract.algo.ts:105
    // return this.boxMbr.value
    app_global_get_ex
    assert // check GlobalState exists
    // contracts/ReferenceAppBox/contract.algo.ts:103
    // @abimethod({ readonly: true })
    itob
    bytec_3 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return


// contracts/ReferenceAppBox/contract.algo.ts::ReferenceAppBox.getBoxConfiguration[routing]() -> void:
getBoxConfiguration:
    // contracts/ReferenceAppBox/contract.algo.ts:114
    // return [this.keyLength.value, this.valueLength.value, this.boxSize.value, this.boxMbr.value]
    intc_1 // 0
    // contracts/ReferenceAppBox/contract.algo.ts:25
    // public keyLength = GlobalState<uint64>({ initialValue: Uint64(32 + 19) }) // Account address (32 bytes) + key prefix overhead (19 bytes)
    bytec_0 // "keyLength"
    // contracts/ReferenceAppBox/contract.algo.ts:114
    // return [this.keyLength.value, this.valueLength.value, this.boxSize.value, this.boxMbr.value]
    app_global_get_ex
    assert // check GlobalState exists
    intc_1 // 0
    // contracts/ReferenceAppBox/contract.algo.ts:26
    // public valueLength = GlobalState<uint64>({ initialValue: Uint64(8) }) // uint64 (8 bytes)
    bytec 4 // "valueLength"
    // contracts/ReferenceAppBox/contract.algo.ts:114
    // return [this.keyLength.value, this.valueLength.value, this.boxSize.value, this.boxMbr.value]
    app_global_get_ex
    assert // check GlobalState exists
    intc_1 // 0
    // contracts/ReferenceAppBox/contract.algo.ts:27
    // public boxSize = GlobalState<uint64>() // Calculated in constructor
    bytec 5 // "boxSize"
    // contracts/ReferenceAppBox/contract.algo.ts:114
    // return [this.keyLength.value, this.valueLength.value, this.boxSize.value, this.boxMbr.value]
    app_global_get_ex
    assert // check GlobalState exists
    intc_1 // 0
    // contracts/ReferenceAppBox/contract.algo.ts:28
    // public boxMbr = GlobalState<uint64>() // Calculated in constructor
    bytec_1 // "boxMbr"
    // contracts/ReferenceAppBox/contract.algo.ts:114
    // return [this.keyLength.value, this.valueLength.value, this.boxSize.value, this.boxMbr.value]
    app_global_get_ex
    assert // check GlobalState exists
    uncover 3
    itob
    uncover 3
    itob
    concat
    uncover 2
    itob
    concat
    swap
    itob
    concat
    // contracts/ReferenceAppBox/contract.algo.ts:112
    // @abimethod({ readonly: true })
    bytec_3 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return


// contracts/ReferenceAppBox/contract.algo.ts::ReferenceAppBox.updateBoxConfiguration[routing]() -> void:
updateBoxConfiguration:
    // contracts/ReferenceAppBox/contract.algo.ts:122
    // @abimethod()
    txna ApplicationArgs 1
    btoi
    txna ApplicationArgs 2
    btoi
    // contracts/ReferenceAppBox/contract.algo.ts:25
    // public keyLength = GlobalState<uint64>({ initialValue: Uint64(32 + 19) }) // Account address (32 bytes) + key prefix overhead (19 bytes)
    bytec_0 // "keyLength"
    // contracts/ReferenceAppBox/contract.algo.ts:124
    // this.keyLength.value = newKeyLength
    uncover 2
    app_global_put
    // contracts/ReferenceAppBox/contract.algo.ts:26
    // public valueLength = GlobalState<uint64>({ initialValue: Uint64(8) }) // uint64 (8 bytes)
    bytec 4 // "valueLength"
    // contracts/ReferenceAppBox/contract.algo.ts:125
    // this.valueLength.value = newValueLength
    dig 1
    app_global_put
    // contracts/ReferenceAppBox/contract.algo.ts:128
    // this.boxSize.value = this.keyLength.value + this.valueLength.value
    intc_1 // 0
    // contracts/ReferenceAppBox/contract.algo.ts:25
    // public keyLength = GlobalState<uint64>({ initialValue: Uint64(32 + 19) }) // Account address (32 bytes) + key prefix overhead (19 bytes)
    bytec_0 // "keyLength"
    // contracts/ReferenceAppBox/contract.algo.ts:128
    // this.boxSize.value = this.keyLength.value + this.valueLength.value
    app_global_get_ex
    assert // check GlobalState exists
    +
    // contracts/ReferenceAppBox/contract.algo.ts:27
    // public boxSize = GlobalState<uint64>() // Calculated in constructor
    bytec 5 // "boxSize"
    // contracts/ReferenceAppBox/contract.algo.ts:128
    // this.boxSize.value = this.keyLength.value + this.valueLength.value
    dig 1
    app_global_put
    // contracts/ReferenceAppBox/contract.algo.ts:129
    // this.boxMbr.value = Uint64(2500) + this.boxSize.value * Uint64(400)
    intc_3 // 400
    *
    pushint 2500 // 2500
    +
    // contracts/ReferenceAppBox/contract.algo.ts:28
    // public boxMbr = GlobalState<uint64>() // Calculated in constructor
    bytec_1 // "boxMbr"
    // contracts/ReferenceAppBox/contract.algo.ts:129
    // this.boxMbr.value = Uint64(2500) + this.boxSize.value * Uint64(400)
    swap
    app_global_put
    // contracts/ReferenceAppBox/contract.algo.ts:122
    // @abimethod()
    intc_0 // 1
    return
