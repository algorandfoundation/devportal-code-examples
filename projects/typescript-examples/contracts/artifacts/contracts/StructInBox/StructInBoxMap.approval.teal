#pragma version 11
#pragma typetrack false

// @algorandfoundation/algorand-typescript/arc4/index.d.ts::Contract.approvalProgram() -> uint64:
main:
    intcblock 1 2 8 10
    bytecblock "users" 0x75736572730000000000000000 0x151f7c7580 0x151f7c75
    // contracts/StructInBox/contract.algo.ts:18
    // export default class StructInBoxMap extends Contract {
    txn NumAppArgs
    bz main___algots__.defaultCreate@11
    txn OnCompletion
    !
    assert // OnCompletion must be NoOp
    txn ApplicationID
    assert
    pushbytess 0xf165cdd9 0x0f05f332 0x699eb0fe 0xd829d2a3 // method "boxMapTest()bool", method "boxMapSet(uint64,(string,uint64,uint64))bool", method "boxMapGet(uint64)(string,uint64,uint64)", method "boxMapExists(uint64)bool"
    txna ApplicationArgs 0
    match boxMapTest boxMapSet boxMapGet boxMapExists
    err

main___algots__.defaultCreate@11:
    // contracts/StructInBox/contract.algo.ts:18
    // export default class StructInBoxMap extends Contract {
    txn OnCompletion
    !
    txn ApplicationID
    !
    &&
    return // on error: OnCompletion must be NoOp && can only call when creating


// contracts/StructInBox/contract.algo.ts::StructInBoxMap.boxMapTest[routing]() -> void:
boxMapTest:
    // contracts/StructInBox/contract.algo.ts:19
    // public userMap = BoxMap<uint64, User>({ keyPrefix: 'users' })
    bytec_1 // 0x75736572730000000000000000
    // contracts/StructInBox/contract.algo.ts:30
    // this.userMap(key0).value = clone(value)
    box_del
    pop
    // contracts/StructInBox/contract.algo.ts:19
    // public userMap = BoxMap<uint64, User>({ keyPrefix: 'users' })
    bytec_1 // 0x75736572730000000000000000
    // contracts/StructInBox/contract.algo.ts:30
    // this.userMap(key0).value = clone(value)
    pushbytes 0x0012000000000000004600000000000000020008746573744e616d65
    box_put
    // contracts/StructInBox/contract.algo.ts:21
    // @abimethod()
    bytec_2 // 0x151f7c7580
    log
    intc_0 // 1
    return


// contracts/StructInBox/contract.algo.ts::StructInBoxMap.boxMapSet[routing]() -> void:
boxMapSet:
    // contracts/StructInBox/contract.algo.ts:35
    // @abimethod()
    txna ApplicationArgs 1
    btoi
    txna ApplicationArgs 2
    // contracts/StructInBox/contract.algo.ts:37
    // this.userMap(key).value = clone(value)
    swap
    itob
    // contracts/StructInBox/contract.algo.ts:19
    // public userMap = BoxMap<uint64, User>({ keyPrefix: 'users' })
    bytec_0 // "users"
    swap
    concat
    // contracts/StructInBox/contract.algo.ts:37
    // this.userMap(key).value = clone(value)
    dup
    box_del
    pop
    dup
    dig 2
    box_put
    // contracts/StructInBox/contract.algo.ts:39-43
    // assertMatch(this.userMap(key).value, {
    //   id: value.id,
    //   asset: value.asset,
    //   name: value.name,
    // })
    dup
    intc_1 // 2
    intc_2 // 8
    box_extract
    btoi
    // contracts/StructInBox/contract.algo.ts:40
    // id: value.id,
    dig 2
    intc_1 // 2
    extract_uint64
    // contracts/StructInBox/contract.algo.ts:39-43
    // assertMatch(this.userMap(key).value, {
    //   id: value.id,
    //   asset: value.asset,
    //   name: value.name,
    // })
    ==
    swap
    intc_3 // 10
    intc_2 // 8
    box_extract
    btoi
    // contracts/StructInBox/contract.algo.ts:41
    // asset: value.asset,
    uncover 2
    intc_3 // 10
    extract_uint64
    // contracts/StructInBox/contract.algo.ts:39-43
    // assertMatch(this.userMap(key).value, {
    //   id: value.id,
    //   asset: value.asset,
    //   name: value.name,
    // })
    ==
    &&
    intc_0 // 1
    &&
    assert // assert target is match for conditions
    // contracts/StructInBox/contract.algo.ts:35
    // @abimethod()
    bytec_2 // 0x151f7c7580
    log
    intc_0 // 1
    return


// contracts/StructInBox/contract.algo.ts::StructInBoxMap.boxMapGet[routing]() -> void:
boxMapGet:
    // contracts/StructInBox/contract.algo.ts:48
    // @abimethod()
    txna ApplicationArgs 1
    btoi
    // contracts/StructInBox/contract.algo.ts:50
    // return this.userMap(key).value
    itob
    // contracts/StructInBox/contract.algo.ts:19
    // public userMap = BoxMap<uint64, User>({ keyPrefix: 'users' })
    bytec_0 // "users"
    swap
    concat
    // contracts/StructInBox/contract.algo.ts:50
    // return this.userMap(key).value
    box_get
    assert // Box must have value
    // contracts/StructInBox/contract.algo.ts:48
    // @abimethod()
    bytec_3 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return


// contracts/StructInBox/contract.algo.ts::StructInBoxMap.boxMapExists[routing]() -> void:
boxMapExists:
    // contracts/StructInBox/contract.algo.ts:53
    // @abimethod()
    txna ApplicationArgs 1
    btoi
    // contracts/StructInBox/contract.algo.ts:55
    // return this.userMap(key).exists
    itob
    // contracts/StructInBox/contract.algo.ts:19
    // public userMap = BoxMap<uint64, User>({ keyPrefix: 'users' })
    bytec_0 // "users"
    swap
    concat
    // contracts/StructInBox/contract.algo.ts:55
    // return this.userMap(key).exists
    box_len
    bury 1
    // contracts/StructInBox/contract.algo.ts:53
    // @abimethod()
    pushbytes 0x00
    pushint 0 // 0
    uncover 2
    setbit
    bytec_3 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return
