#pragma version 11
#pragma typetrack false

// @algorandfoundation/algorand-typescript/arc4/index.d.ts::Contract.approvalProgram() -> uint64:
main:
    intcblock 1 0 2 42
    bytecblock 0x151f7c75 "boxMap" "boxInt" 0x00010203 0x00 "boxString" "boxDynamicBytes" "users" "42"
    // contracts/BoxStorage/contract.algo.ts:41
    // export default class BoxStorage extends Contract {
    txn NumAppArgs
    bz main___algots__.defaultCreate@28
    txn OnCompletion
    !
    assert // OnCompletion must be NoOp
    txn ApplicationID
    assert
    pushbytess 0xb7491344 0x49cf4105 0x6ab3e9bc 0x26ca648a 0x28cc7139 0x644a3994 0xb1f5a9b6 0xd829d2a3 0xfa1562f7 0xc497bc6f 0xf4f9cbad 0x9e11fd7a 0xf53418c4 0x9101a7de 0xa4552eb5 0xcb31fa33 0x799689d5 0x156ef28d 0xb2d39fea 0x0a4036cd 0x547f0a74 // method "getBox()uint64", method "valueBox()uint64", method "maybeBox()(uint64,bool)", method "getBoxMap(uint64)string", method "getBoxMapWithDefault(uint64)string", method "maybeBoxMap(uint64)(string,bool)", method "keyPrefixBoxMap()byte[]", method "boxMapExists(uint64)bool", method "setBox(uint64)void", method "setBoxString(string)void", method "setBoxDynamicBytes(byte[])void", method "setBoxMap(uint64,string)void", method "boxMapLength(uint64)uint64", method "deleteBox()void", method "deleteBoxMap(uint64)void", method "extractBox(string)void", method "getBoxMapObject(uint64)(string,uint64,uint64)", method "boxMapObjectExists(uint64)bool", method "setBoxMapObject(uint64,(string,uint64,uint64))bool", method "boxMapObjectLength(uint64)uint64", method "arc4Box(string)uint8[4]"
    txna ApplicationArgs 0
    match getBox valueBox maybeBox getBoxMap getBoxMapWithDefault maybeBoxMap main_keyPrefixBoxMap_route@10 boxMapExists setBox setBoxString setBoxDynamicBytes setBoxMap boxMapLength deleteBox deleteBoxMap extractBox getBoxMapObject boxMapObjectExists setBoxMapObject boxMapObjectLength arc4Box
    err

main_keyPrefixBoxMap_route@10:
    // contracts/BoxStorage/contract.algo.ts:114-115
    // @readonly
    // public keyPrefixBoxMap(): bytes {
    pushbytes 0x151f7c750006626f784d6170
    log
    intc_0 // 1
    return

main___algots__.defaultCreate@28:
    // contracts/BoxStorage/contract.algo.ts:41
    // export default class BoxStorage extends Contract {
    txn OnCompletion
    !
    txn ApplicationID
    !
    &&
    return // on error: OnCompletion must be NoOp && can only call when creating


// contracts/BoxStorage/contract.algo.ts::BoxStorage.getBox[routing]() -> void:
getBox:
    // contracts/BoxStorage/contract.algo.ts:44
    // public boxInt = Box<uint64>({ key: 'boxInt' })
    bytec_2 // "boxInt"
    // contracts/BoxStorage/contract.algo.ts:58
    // return this.boxInt.value
    box_get
    assert // Box must have value
    btoi
    // contracts/BoxStorage/contract.algo.ts:56-57
    // @readonly
    // public getBox(): uint64 {
    itob
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return


// contracts/BoxStorage/contract.algo.ts::BoxStorage.valueBox[routing]() -> void:
valueBox:
    // contracts/BoxStorage/contract.algo.ts:44
    // public boxInt = Box<uint64>({ key: 'boxInt' })
    bytec_2 // "boxInt"
    // contracts/BoxStorage/contract.algo.ts:66
    // return this.boxInt.value
    box_get
    assert // Box must have value
    btoi
    // contracts/BoxStorage/contract.algo.ts:64-65
    // @readonly
    // public valueBox(): uint64 {
    itob
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return


// contracts/BoxStorage/contract.algo.ts::BoxStorage.maybeBox[routing]() -> void:
maybeBox:
    // contracts/BoxStorage/contract.algo.ts:44
    // public boxInt = Box<uint64>({ key: 'boxInt' })
    bytec_2 // "boxInt"
    // contracts/BoxStorage/contract.algo.ts:75
    // const [boxIntValue, boxIntExists] = this.boxInt.maybe()
    box_get
    swap
    btoi
    // contracts/BoxStorage/contract.algo.ts:76
    // return [boxIntValue, boxIntExists]
    itob
    bytec 4 // 0x00
    intc_1 // 0
    uncover 3
    setbit
    concat
    // contracts/BoxStorage/contract.algo.ts:73-74
    // @readonly
    // public maybeBox(): [uint64, boolean] {
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return


// contracts/BoxStorage/contract.algo.ts::BoxStorage.getBoxMap[routing]() -> void:
getBoxMap:
    // contracts/BoxStorage/contract.algo.ts:84-85
    // @readonly
    // public getBoxMap(key: uint64): string {
    txna ApplicationArgs 1
    btoi
    // contracts/BoxStorage/contract.algo.ts:86
    // return this.boxMap(key).value
    itob
    // contracts/BoxStorage/contract.algo.ts:47
    // public boxMap = BoxMap<uint64, string>({ keyPrefix: 'boxMap' })
    bytec_1 // "boxMap"
    swap
    concat
    // contracts/BoxStorage/contract.algo.ts:86
    // return this.boxMap(key).value
    box_get
    assert // Box must have value
    // contracts/BoxStorage/contract.algo.ts:84-85
    // @readonly
    // public getBoxMap(key: uint64): string {
    dup
    len
    itob
    extract 6 2
    swap
    concat
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return


// contracts/BoxStorage/contract.algo.ts::BoxStorage.getBoxMapWithDefault[routing]() -> void:
getBoxMapWithDefault:
    // contracts/BoxStorage/contract.algo.ts:94-95
    // @readonly
    // public getBoxMapWithDefault(key: uint64): string {
    txna ApplicationArgs 1
    btoi
    // contracts/BoxStorage/contract.algo.ts:96
    // return this.boxMap(key).get({ default: 'default' })
    itob
    // contracts/BoxStorage/contract.algo.ts:47
    // public boxMap = BoxMap<uint64, string>({ keyPrefix: 'boxMap' })
    bytec_1 // "boxMap"
    swap
    concat
    // contracts/BoxStorage/contract.algo.ts:96
    // return this.boxMap(key).get({ default: 'default' })
    box_get
    pushbytes "default"
    cover 2
    select
    // contracts/BoxStorage/contract.algo.ts:94-95
    // @readonly
    // public getBoxMapWithDefault(key: uint64): string {
    dup
    len
    itob
    extract 6 2
    swap
    concat
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return


// contracts/BoxStorage/contract.algo.ts::BoxStorage.maybeBoxMap[routing]() -> void:
maybeBoxMap:
    // contracts/BoxStorage/contract.algo.ts:104-105
    // @readonly
    // public maybeBoxMap(key: uint64): [string, boolean] {
    txna ApplicationArgs 1
    btoi
    // contracts/BoxStorage/contract.algo.ts:106
    // const [value, exists] = this.boxMap(key).maybe()
    itob
    // contracts/BoxStorage/contract.algo.ts:47
    // public boxMap = BoxMap<uint64, string>({ keyPrefix: 'boxMap' })
    bytec_1 // "boxMap"
    swap
    concat
    // contracts/BoxStorage/contract.algo.ts:106
    // const [value, exists] = this.boxMap(key).maybe()
    box_get
    dup
    uncover 2
    swap
    // contracts/BoxStorage/contract.algo.ts:107
    // return [exists ? value : '', exists]
    bz maybeBoxMap_ternary_false@3
    dup

maybeBoxMap_ternary_merge@4:
    // contracts/BoxStorage/contract.algo.ts:107
    // return [exists ? value : '', exists]
    dup
    len
    itob
    extract 6 2
    swap
    concat
    bytec 4 // 0x00
    intc_1 // 0
    dig 4
    setbit
    pushbytes 0x0003
    swap
    concat
    swap
    concat
    // contracts/BoxStorage/contract.algo.ts:104-105
    // @readonly
    // public maybeBoxMap(key: uint64): [string, boolean] {
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return

maybeBoxMap_ternary_false@3:
    // contracts/BoxStorage/contract.algo.ts:107
    // return [exists ? value : '', exists]
    pushbytes ""
    b maybeBoxMap_ternary_merge@4


// contracts/BoxStorage/contract.algo.ts::BoxStorage.boxMapExists[routing]() -> void:
boxMapExists:
    // contracts/BoxStorage/contract.algo.ts:124-125
    // @readonly
    // public boxMapExists(key: uint64): boolean {
    txna ApplicationArgs 1
    btoi
    // contracts/BoxStorage/contract.algo.ts:126
    // return this.boxMap(key).exists
    itob
    // contracts/BoxStorage/contract.algo.ts:47
    // public boxMap = BoxMap<uint64, string>({ keyPrefix: 'boxMap' })
    bytec_1 // "boxMap"
    swap
    concat
    // contracts/BoxStorage/contract.algo.ts:126
    // return this.boxMap(key).exists
    box_len
    bury 1
    // contracts/BoxStorage/contract.algo.ts:124-125
    // @readonly
    // public boxMapExists(key: uint64): boolean {
    bytec 4 // 0x00
    intc_1 // 0
    uncover 2
    setbit
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return


// contracts/BoxStorage/contract.algo.ts::BoxStorage.setBox[routing]() -> void:
setBox:
    // contracts/BoxStorage/contract.algo.ts:135
    // public setBox(valueInt: uint64): void {
    txna ApplicationArgs 1
    btoi
    // contracts/BoxStorage/contract.algo.ts:136
    // this.boxInt.value = valueInt
    itob
    // contracts/BoxStorage/contract.algo.ts:44
    // public boxInt = Box<uint64>({ key: 'boxInt' })
    bytec_2 // "boxInt"
    // contracts/BoxStorage/contract.algo.ts:136
    // this.boxInt.value = valueInt
    swap
    box_put
    // contracts/BoxStorage/contract.algo.ts:135
    // public setBox(valueInt: uint64): void {
    intc_0 // 1
    return


// contracts/BoxStorage/contract.algo.ts::BoxStorage.setBoxString[routing]() -> void:
setBoxString:
    // contracts/BoxStorage/contract.algo.ts:143
    // public setBoxString(value: string): void {
    txna ApplicationArgs 1
    extract 2 0
    // contracts/BoxStorage/contract.algo.ts:43
    // public boxString = Box<string>({ key: 'boxString' })
    bytec 5 // "boxString"
    // contracts/BoxStorage/contract.algo.ts:144
    // this.boxString.value = value
    box_del
    pop
    // contracts/BoxStorage/contract.algo.ts:43
    // public boxString = Box<string>({ key: 'boxString' })
    bytec 5 // "boxString"
    // contracts/BoxStorage/contract.algo.ts:144
    // this.boxString.value = value
    swap
    box_put
    // contracts/BoxStorage/contract.algo.ts:143
    // public setBoxString(value: string): void {
    intc_0 // 1
    return


// contracts/BoxStorage/contract.algo.ts::BoxStorage.setBoxDynamicBytes[routing]() -> void:
setBoxDynamicBytes:
    // contracts/BoxStorage/contract.algo.ts:151
    // public setBoxDynamicBytes(value: arc4.DynamicBytes): void {
    txna ApplicationArgs 1
    // contracts/BoxStorage/contract.algo.ts:46
    // public boxDynamicBytes = Box<arc4.DynamicBytes>({ key: 'boxDynamicBytes' })
    bytec 6 // "boxDynamicBytes"
    // contracts/BoxStorage/contract.algo.ts:152
    // this.boxDynamicBytes.value = value
    box_del
    pop
    // contracts/BoxStorage/contract.algo.ts:46
    // public boxDynamicBytes = Box<arc4.DynamicBytes>({ key: 'boxDynamicBytes' })
    bytec 6 // "boxDynamicBytes"
    // contracts/BoxStorage/contract.algo.ts:152
    // this.boxDynamicBytes.value = value
    swap
    box_put
    // contracts/BoxStorage/contract.algo.ts:151
    // public setBoxDynamicBytes(value: arc4.DynamicBytes): void {
    intc_0 // 1
    return


// contracts/BoxStorage/contract.algo.ts::BoxStorage.setBoxMap[routing]() -> void:
setBoxMap:
    // contracts/BoxStorage/contract.algo.ts:160
    // public setBoxMap(key: uint64, value: string): void {
    txna ApplicationArgs 1
    btoi
    txna ApplicationArgs 2
    extract 2 0
    // contracts/BoxStorage/contract.algo.ts:161
    // this.boxMap(key).value = value
    swap
    itob
    // contracts/BoxStorage/contract.algo.ts:47
    // public boxMap = BoxMap<uint64, string>({ keyPrefix: 'boxMap' })
    bytec_1 // "boxMap"
    swap
    concat
    // contracts/BoxStorage/contract.algo.ts:161
    // this.boxMap(key).value = value
    dup
    box_del
    pop
    swap
    box_put
    // contracts/BoxStorage/contract.algo.ts:160
    // public setBoxMap(key: uint64, value: string): void {
    intc_0 // 1
    return


// contracts/BoxStorage/contract.algo.ts::BoxStorage.boxMapLength[routing]() -> void:
boxMapLength:
    // contracts/BoxStorage/contract.algo.ts:171-172
    // @readonly
    // public boxMapLength(key: uint64): uint64 {
    txna ApplicationArgs 1
    btoi
    // contracts/BoxStorage/contract.algo.ts:173
    // if (!this.boxMap(key).exists) {
    itob
    // contracts/BoxStorage/contract.algo.ts:47
    // public boxMap = BoxMap<uint64, string>({ keyPrefix: 'boxMap' })
    bytec_1 // "boxMap"
    swap
    concat
    dup
    // contracts/BoxStorage/contract.algo.ts:173
    // if (!this.boxMap(key).exists) {
    box_len
    bury 1
    bnz boxMapLength_after_if_else@3
    // contracts/BoxStorage/contract.algo.ts:174
    // return Uint64(0)
    intc_1 // 0

boxMapLength_after_inlined_contracts/BoxStorage/contract.algo.ts::BoxStorage.boxMapLength@4:
    // contracts/BoxStorage/contract.algo.ts:171-172
    // @readonly
    // public boxMapLength(key: uint64): uint64 {
    itob
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return

boxMapLength_after_if_else@3:
    // contracts/BoxStorage/contract.algo.ts:177
    // return this.boxMap(key).length
    dup
    box_len
    assert // Box must have value
    // contracts/BoxStorage/contract.algo.ts:171-172
    // @readonly
    // public boxMapLength(key: uint64): uint64 {
    b boxMapLength_after_inlined_contracts/BoxStorage/contract.algo.ts::BoxStorage.boxMapLength@4


// contracts/BoxStorage/contract.algo.ts::BoxStorage.deleteBox[routing]() -> void:
deleteBox:
    // contracts/BoxStorage/contract.algo.ts:44
    // public boxInt = Box<uint64>({ key: 'boxInt' })
    bytec_2 // "boxInt"
    // contracts/BoxStorage/contract.algo.ts:186
    // this.boxInt.delete()
    box_del
    pop
    // contracts/BoxStorage/contract.algo.ts:46
    // public boxDynamicBytes = Box<arc4.DynamicBytes>({ key: 'boxDynamicBytes' })
    bytec 6 // "boxDynamicBytes"
    // contracts/BoxStorage/contract.algo.ts:187
    // this.boxDynamicBytes.delete()
    box_del
    pop
    // contracts/BoxStorage/contract.algo.ts:43
    // public boxString = Box<string>({ key: 'boxString' })
    bytec 5 // "boxString"
    // contracts/BoxStorage/contract.algo.ts:188
    // this.boxString.delete()
    box_del
    pop
    // contracts/BoxStorage/contract.algo.ts:44
    // public boxInt = Box<uint64>({ key: 'boxInt' })
    bytec_2 // "boxInt"
    // contracts/BoxStorage/contract.algo.ts:190
    // assert(this.boxInt.get({ default: Uint64(42) }) === 42)
    box_get
    swap
    btoi
    intc_3 // 42
    swap
    uncover 2
    select
    intc_3 // 42
    ==
    assert
    // contracts/BoxStorage/contract.algo.ts:46
    // public boxDynamicBytes = Box<arc4.DynamicBytes>({ key: 'boxDynamicBytes' })
    bytec 6 // "boxDynamicBytes"
    // contracts/BoxStorage/contract.algo.ts:191
    // assert(this.boxDynamicBytes.get({ default: new arc4.DynamicBytes('42') }).native === Bytes('42'))
    box_get
    pushbytes 0x00023432
    cover 2
    select
    extract 2 0
    bytec 8 // "42"
    ==
    assert
    // contracts/BoxStorage/contract.algo.ts:43
    // public boxString = Box<string>({ key: 'boxString' })
    bytec 5 // "boxString"
    // contracts/BoxStorage/contract.algo.ts:192
    // assert(this.boxString.get({ default: '42' }) === '42')
    box_get
    bytec 8 // "42"
    cover 2
    select
    bytec 8 // "42"
    ==
    // contracts/BoxStorage/contract.algo.ts:185
    // public deleteBox(): void {
    return


// contracts/BoxStorage/contract.algo.ts::BoxStorage.deleteBoxMap[routing]() -> void:
deleteBoxMap:
    // contracts/BoxStorage/contract.algo.ts:199
    // public deleteBoxMap(key: uint64): void {
    txna ApplicationArgs 1
    btoi
    // contracts/BoxStorage/contract.algo.ts:200
    // this.boxMap(key).delete()
    itob
    // contracts/BoxStorage/contract.algo.ts:47
    // public boxMap = BoxMap<uint64, string>({ keyPrefix: 'boxMap' })
    bytec_1 // "boxMap"
    swap
    concat
    // contracts/BoxStorage/contract.algo.ts:200
    // this.boxMap(key).delete()
    box_del
    pop
    // contracts/BoxStorage/contract.algo.ts:199
    // public deleteBoxMap(key: uint64): void {
    intc_0 // 1
    return


// contracts/BoxStorage/contract.algo.ts::BoxStorage.extractBox[routing]() -> void:
extractBox:
    // contracts/BoxStorage/contract.algo.ts:209
    // public extractBox(key: string): void {
    txna ApplicationArgs 1
    extract 2 0
    // contracts/BoxStorage/contract.algo.ts:210
    // const senderBytes = Txn.sender.bytes
    txn Sender
    // contracts/BoxStorage/contract.algo.ts:211
    // const appAddress = Global.currentApplicationAddress.bytes
    global CurrentApplicationAddress
    // contracts/BoxStorage/contract.algo.ts:215
    // assert(box.create({ size: totalSize }), 'box creation failed')
    dig 2
    // contracts/BoxStorage/contract.algo.ts:212
    // const totalSize = Uint64(appAddress.length + senderBytes.length)
    pushint 64 // 64
    // contracts/BoxStorage/contract.algo.ts:215
    // assert(box.create({ size: totalSize }), 'box creation failed')
    box_create
    assert // box creation failed
    // contracts/BoxStorage/contract.algo.ts:217
    // box.replace(0, senderBytes)
    dig 2
    intc_1 // 0
    dig 3
    box_replace
    // contracts/BoxStorage/contract.algo.ts:218
    // box.splice(0, 0, appAddress)
    dig 2
    intc_1 // 0
    dup
    dig 3
    box_splice
    // contracts/BoxStorage/contract.algo.ts:220
    // const part1 = box.extract(0, 32)
    dig 2
    intc_1 // 0
    pushint 32 // 32
    box_extract
    // contracts/BoxStorage/contract.algo.ts:221
    // const part2 = box.extract(32, 32)
    uncover 3
    pushint 32 // 32
    dup
    box_extract
    // contracts/BoxStorage/contract.algo.ts:223
    // assert(part1.equals(appAddress), 'First part should match app address')
    swap
    uncover 2
    ==
    assert // First part should match app address
    // contracts/BoxStorage/contract.algo.ts:224
    // assert(part2.equals(senderBytes), 'Second part should match sender bytes')
    ==
    // contracts/BoxStorage/contract.algo.ts:209
    // public extractBox(key: string): void {
    return // on error: Second part should match sender bytes


// contracts/BoxStorage/contract.algo.ts::BoxStorage.getBoxMapObject[routing]() -> void:
getBoxMapObject:
    // contracts/BoxStorage/contract.algo.ts:234-235
    // @readonly
    // public getBoxMapObject(key: uint64): User {
    txna ApplicationArgs 1
    btoi
    // contracts/BoxStorage/contract.algo.ts:236
    // return this.boxMapObject(key).value
    itob
    // contracts/BoxStorage/contract.algo.ts:48
    // public boxMapObject = BoxMap<uint64, User>({ keyPrefix: 'users' })
    bytec 7 // "users"
    swap
    concat
    // contracts/BoxStorage/contract.algo.ts:236
    // return this.boxMapObject(key).value
    box_get
    assert // Box must have value
    // contracts/BoxStorage/contract.algo.ts:234-235
    // @readonly
    // public getBoxMapObject(key: uint64): User {
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return


// contracts/BoxStorage/contract.algo.ts::BoxStorage.boxMapObjectExists[routing]() -> void:
boxMapObjectExists:
    // contracts/BoxStorage/contract.algo.ts:244-245
    // @readonly
    // public boxMapObjectExists(key: uint64): boolean {
    txna ApplicationArgs 1
    btoi
    // contracts/BoxStorage/contract.algo.ts:246
    // return this.boxMapObject(key).exists
    itob
    // contracts/BoxStorage/contract.algo.ts:48
    // public boxMapObject = BoxMap<uint64, User>({ keyPrefix: 'users' })
    bytec 7 // "users"
    swap
    concat
    // contracts/BoxStorage/contract.algo.ts:246
    // return this.boxMapObject(key).exists
    box_len
    bury 1
    // contracts/BoxStorage/contract.algo.ts:244-245
    // @readonly
    // public boxMapObjectExists(key: uint64): boolean {
    bytec 4 // 0x00
    intc_1 // 0
    uncover 2
    setbit
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return


// contracts/BoxStorage/contract.algo.ts::BoxStorage.setBoxMapObject[routing]() -> void:
setBoxMapObject:
    // contracts/BoxStorage/contract.algo.ts:254
    // public setBoxMapObject(key: uint64, value: User): boolean {
    txna ApplicationArgs 1
    btoi
    txna ApplicationArgs 2
    // contracts/BoxStorage/contract.algo.ts:255
    // this.boxMapObject(key).value = clone(value)
    swap
    itob
    // contracts/BoxStorage/contract.algo.ts:48
    // public boxMapObject = BoxMap<uint64, User>({ keyPrefix: 'users' })
    bytec 7 // "users"
    swap
    concat
    // contracts/BoxStorage/contract.algo.ts:255
    // this.boxMapObject(key).value = clone(value)
    dup
    box_del
    pop
    dup
    dig 2
    box_put
    // contracts/BoxStorage/contract.algo.ts:256-264
    // assertMatch(
    //   this.boxMapObject(key).value,
    //   {
    //     name: value.name,
    //     id: value.id,
    //     asset: value.asset,
    //   },
    //   'boxMapObject value mismatch',
    // )
    dup
    intc_2 // 2
    pushint 8 // 8
    box_extract
    btoi
    // contracts/BoxStorage/contract.algo.ts:260
    // id: value.id,
    dig 2
    intc_2 // 2
    extract_uint64
    // contracts/BoxStorage/contract.algo.ts:256-264
    // assertMatch(
    //   this.boxMapObject(key).value,
    //   {
    //     name: value.name,
    //     id: value.id,
    //     asset: value.asset,
    //   },
    //   'boxMapObject value mismatch',
    // )
    ==
    intc_0 // 1
    &&
    swap
    pushints 10 8 // 10, 8
    box_extract
    btoi
    // contracts/BoxStorage/contract.algo.ts:261
    // asset: value.asset,
    uncover 2
    pushint 10 // 10
    extract_uint64
    // contracts/BoxStorage/contract.algo.ts:256-264
    // assertMatch(
    //   this.boxMapObject(key).value,
    //   {
    //     name: value.name,
    //     id: value.id,
    //     asset: value.asset,
    //   },
    //   'boxMapObject value mismatch',
    // )
    ==
    &&
    assert // boxMapObject value mismatch
    // contracts/BoxStorage/contract.algo.ts:254
    // public setBoxMapObject(key: uint64, value: User): boolean {
    pushbytes 0x151f7c7580
    log
    intc_0 // 1
    return


// contracts/BoxStorage/contract.algo.ts::BoxStorage.boxMapObjectLength[routing]() -> void:
boxMapObjectLength:
    // contracts/BoxStorage/contract.algo.ts:273
    // public boxMapObjectLength(key: uint64): uint64 {
    txna ApplicationArgs 1
    btoi
    // contracts/BoxStorage/contract.algo.ts:280
    // this.boxMapObject(key).value = clone(value)
    itob
    // contracts/BoxStorage/contract.algo.ts:48
    // public boxMapObject = BoxMap<uint64, User>({ keyPrefix: 'users' })
    bytec 7 // "users"
    swap
    concat
    // contracts/BoxStorage/contract.algo.ts:280
    // this.boxMapObject(key).value = clone(value)
    dup
    box_del
    pop
    dup
    pushbytes 0x0012000000000000004600000000000004d20008746573744e616d65
    box_put
    // contracts/BoxStorage/contract.algo.ts:282
    // return this.boxMapObject(key).length
    box_len
    pop
    // contracts/BoxStorage/contract.algo.ts:273
    // public boxMapObjectLength(key: uint64): uint64 {
    itob
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return


// contracts/BoxStorage/contract.algo.ts::BoxStorage.arc4Box[routing]() -> void:
arc4Box:
    // contracts/BoxStorage/contract.algo.ts:292
    // public arc4Box(key: string): Uint8x4 {
    txna ApplicationArgs 1
    extract 2 0
    // contracts/BoxStorage/contract.algo.ts:295
    // staticIntBox.value = new FixedArray<arc4.Uint8, 4>(new Uint8(0), new Uint8(1), new Uint8(2), new Uint8(3))
    bytec_3 // 0x00010203
    box_put
    bytec_3 // 0x00010203
    // contracts/BoxStorage/contract.algo.ts:297
    // assert(staticIntBox.value[0].asUint64() === 0)
    intc_1 // 0
    getbyte
    !
    assert
    // contracts/BoxStorage/contract.algo.ts:295
    // staticIntBox.value = new FixedArray<arc4.Uint8, 4>(new Uint8(0), new Uint8(1), new Uint8(2), new Uint8(3))
    bytec_3 // 0x00010203
    // contracts/BoxStorage/contract.algo.ts:298
    // assert(staticIntBox.value[1].asUint64() === 1)
    intc_0 // 1
    getbyte
    intc_0 // 1
    ==
    assert
    // contracts/BoxStorage/contract.algo.ts:295
    // staticIntBox.value = new FixedArray<arc4.Uint8, 4>(new Uint8(0), new Uint8(1), new Uint8(2), new Uint8(3))
    bytec_3 // 0x00010203
    // contracts/BoxStorage/contract.algo.ts:299
    // assert(staticIntBox.value[2].asUint64() === 2)
    intc_2 // 2
    getbyte
    intc_2 // 2
    ==
    assert
    // contracts/BoxStorage/contract.algo.ts:295
    // staticIntBox.value = new FixedArray<arc4.Uint8, 4>(new Uint8(0), new Uint8(1), new Uint8(2), new Uint8(3))
    bytec_3 // 0x00010203
    // contracts/BoxStorage/contract.algo.ts:300
    // assert(staticIntBox.value[3].asUint64() === 3)
    pushint 3 // 3
    getbyte
    pushint 3 // 3
    ==
    assert
    // contracts/BoxStorage/contract.algo.ts:292
    // public arc4Box(key: string): Uint8x4 {
    pushbytes 0x151f7c7500010203
    log
    intc_0 // 1
    return
