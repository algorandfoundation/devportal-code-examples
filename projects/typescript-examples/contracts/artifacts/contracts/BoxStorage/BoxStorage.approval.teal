#pragma version 10
#pragma typetrack false

// @algorandfoundation/algorand-typescript/arc4/index.d.ts::Contract.approvalProgram() -> uint64:
main:
    intcblock 1 0 32 2
    bytecblock 0x151f7c75 "boxMap" 0x00 "boxInt" 0x00010203 "boxString" "boxDynamicBytes" "users" "42" 0x0003 "boxRef"
    // contracts/BoxStorage/contract.algo.ts:43
    // export default class BoxStorage extends Contract {
    txn NumAppArgs
    bz main_bare_routing@31
    pushbytess 0xb7491344 0x49cf4105 0x6ab3e9bc 0x26ca648a 0x28cc7139 0x644a3994 0xb1f5a9b6 0x03e8c77e 0xd829d2a3 0x8c22bfd5 0xfa1562f7 0xc497bc6f 0xf4f9cbad 0x9e11fd7a 0x5e6ceac0 0xf53418c4 0x39e9b226 0x9101a7de 0xa4552eb5 0x38acf53e 0x8600e0eb 0x799689d5 0x156ef28d 0xb2d39fea 0x0a4036cd 0x547f0a74 // method "getBox()uint64", method "valueBox()uint64", method "maybeBox()(uint64,bool)", method "getBoxMap(uint64)string", method "getBoxMapWithDefault(uint64)string", method "maybeBoxMap(uint64)(string,bool)", method "keyPrefixBoxMap()byte[]", method "getBoxRef()address", method "boxMapExists(uint64)bool", method "maybeBoxRef(string)(byte[],bool)", method "setBox(uint64)void", method "setBoxString(string)void", method "setBoxDynamicBytes(byte[])void", method "setBoxMap(uint64,string)void", method "setBoxRef(string)void", method "boxMapLength(uint64)uint64", method "lengthBoxRef(string)uint64", method "deleteBox()void", method "deleteBoxMap(uint64)void", method "deleteBoxRef(string)void", method "extractBoxRef(string)void", method "getBoxMapObject(uint64)(string,uint64,uint64)", method "boxMapObjectExists(uint64)bool", method "setBoxMapObject(uint64,(string,uint64,uint64))bool", method "boxMapObjectLength(uint64)uint64", method "arc4Box(string)uint8[4]"
    txna ApplicationArgs 0
    match main_getBox_route@3 main_valueBox_route@4 main_maybeBox_route@5 main_getBoxMap_route@6 main_getBoxMapWithDefault_route@7 main_maybeBoxMap_route@8 main_keyPrefixBoxMap_route@9 main_getBoxRef_route@10 main_boxMapExists_route@11 main_maybeBoxRef_route@12 main_setBox_route@13 main_setBoxString_route@14 main_setBoxDynamicBytes_route@15 main_setBoxMap_route@16 main_setBoxRef_route@17 main_boxMapLength_route@18 main_lengthBoxRef_route@19 main_deleteBox_route@20 main_deleteBoxMap_route@21 main_deleteBoxRef_route@22 main_extractBoxRef_route@23 main_getBoxMapObject_route@24 main_boxMapObjectExists_route@25 main_setBoxMapObject_route@26 main_boxMapObjectLength_route@27 main_arc4Box_route@28

main_after_if_else@35:
    err

main_arc4Box_route@28:
    // contracts/BoxStorage/contract.algo.ts:352
    // public arc4Box(key: string): Uint8x4 {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // contracts/BoxStorage/contract.algo.ts:43
    // export default class BoxStorage extends Contract {
    txna ApplicationArgs 1
    extract 2 0
    // contracts/BoxStorage/contract.algo.ts:352
    // public arc4Box(key: string): Uint8x4 {
    callsub arc4Box
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return

main_boxMapObjectLength_route@27:
    // contracts/BoxStorage/contract.algo.ts:333
    // public boxMapObjectLength(key: uint64): uint64 {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // contracts/BoxStorage/contract.algo.ts:43
    // export default class BoxStorage extends Contract {
    txna ApplicationArgs 1
    btoi
    // contracts/BoxStorage/contract.algo.ts:333
    // public boxMapObjectLength(key: uint64): uint64 {
    callsub boxMapObjectLength
    itob
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return

main_setBoxMapObject_route@26:
    // contracts/BoxStorage/contract.algo.ts:314
    // public setBoxMapObject(key: uint64, value: User): boolean {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // contracts/BoxStorage/contract.algo.ts:43
    // export default class BoxStorage extends Contract {
    txna ApplicationArgs 1
    btoi
    txna ApplicationArgs 2
    // contracts/BoxStorage/contract.algo.ts:314
    // public setBoxMapObject(key: uint64, value: User): boolean {
    callsub setBoxMapObject
    bytec_2 // 0x00
    intc_1 // 0
    uncover 2
    setbit
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return

main_boxMapObjectExists_route@25:
    // contracts/BoxStorage/contract.algo.ts:304
    // @abimethod({ readonly: true })
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // contracts/BoxStorage/contract.algo.ts:43
    // export default class BoxStorage extends Contract {
    txna ApplicationArgs 1
    btoi
    // contracts/BoxStorage/contract.algo.ts:304
    // @abimethod({ readonly: true })
    callsub boxMapObjectExists
    bytec_2 // 0x00
    intc_1 // 0
    uncover 2
    setbit
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return

main_getBoxMapObject_route@24:
    // contracts/BoxStorage/contract.algo.ts:294
    // @abimethod({ readonly: true })
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // contracts/BoxStorage/contract.algo.ts:43
    // export default class BoxStorage extends Contract {
    txna ApplicationArgs 1
    btoi
    // contracts/BoxStorage/contract.algo.ts:294
    // @abimethod({ readonly: true })
    callsub getBoxMapObject
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return

main_extractBoxRef_route@23:
    // contracts/BoxStorage/contract.algo.ts:268
    // public extractBoxRef(key: string): void {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // contracts/BoxStorage/contract.algo.ts:43
    // export default class BoxStorage extends Contract {
    txna ApplicationArgs 1
    extract 2 0
    // contracts/BoxStorage/contract.algo.ts:268
    // public extractBoxRef(key: string): void {
    callsub extractBoxRef
    intc_0 // 1
    return

main_deleteBoxRef_route@22:
    // contracts/BoxStorage/contract.algo.ts:256
    // public deleteBoxRef(key: string): void {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // contracts/BoxStorage/contract.algo.ts:43
    // export default class BoxStorage extends Contract {
    txna ApplicationArgs 1
    extract 2 0
    // contracts/BoxStorage/contract.algo.ts:256
    // public deleteBoxRef(key: string): void {
    callsub deleteBoxRef
    intc_0 // 1
    return

main_deleteBoxMap_route@21:
    // contracts/BoxStorage/contract.algo.ts:248
    // public deleteBoxMap(key: uint64): void {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // contracts/BoxStorage/contract.algo.ts:43
    // export default class BoxStorage extends Contract {
    txna ApplicationArgs 1
    btoi
    // contracts/BoxStorage/contract.algo.ts:248
    // public deleteBoxMap(key: uint64): void {
    callsub deleteBoxMap
    intc_0 // 1
    return

main_deleteBox_route@20:
    // contracts/BoxStorage/contract.algo.ts:234
    // public deleteBox(): void {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    callsub deleteBox
    intc_0 // 1
    return

main_lengthBoxRef_route@19:
    // contracts/BoxStorage/contract.algo.ts:223
    // public lengthBoxRef(key: string): uint64 {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // contracts/BoxStorage/contract.algo.ts:43
    // export default class BoxStorage extends Contract {
    txna ApplicationArgs 1
    extract 2 0
    // contracts/BoxStorage/contract.algo.ts:223
    // public lengthBoxRef(key: string): uint64 {
    callsub lengthBoxRef
    itob
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return

main_boxMapLength_route@18:
    // contracts/BoxStorage/contract.algo.ts:209
    // @abimethod({ readonly: true })
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // contracts/BoxStorage/contract.algo.ts:43
    // export default class BoxStorage extends Contract {
    txna ApplicationArgs 1
    btoi
    // contracts/BoxStorage/contract.algo.ts:209
    // @abimethod({ readonly: true })
    callsub boxMapLength
    itob
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return

main_setBoxRef_route@17:
    // contracts/BoxStorage/contract.algo.ts:195
    // public setBoxRef(key: string): void {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // contracts/BoxStorage/contract.algo.ts:43
    // export default class BoxStorage extends Contract {
    txna ApplicationArgs 1
    extract 2 0
    // contracts/BoxStorage/contract.algo.ts:195
    // public setBoxRef(key: string): void {
    callsub setBoxRef
    intc_0 // 1
    return

main_setBoxMap_route@16:
    // contracts/BoxStorage/contract.algo.ts:187
    // public setBoxMap(key: uint64, value: string): void {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // contracts/BoxStorage/contract.algo.ts:43
    // export default class BoxStorage extends Contract {
    txna ApplicationArgs 1
    btoi
    txna ApplicationArgs 2
    extract 2 0
    // contracts/BoxStorage/contract.algo.ts:187
    // public setBoxMap(key: uint64, value: string): void {
    callsub setBoxMap
    intc_0 // 1
    return

main_setBoxDynamicBytes_route@15:
    // contracts/BoxStorage/contract.algo.ts:178
    // public setBoxDynamicBytes(value: arc4.DynamicBytes): void {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // contracts/BoxStorage/contract.algo.ts:43
    // export default class BoxStorage extends Contract {
    txna ApplicationArgs 1
    // contracts/BoxStorage/contract.algo.ts:178
    // public setBoxDynamicBytes(value: arc4.DynamicBytes): void {
    callsub setBoxDynamicBytes
    intc_0 // 1
    return

main_setBoxString_route@14:
    // contracts/BoxStorage/contract.algo.ts:170
    // public setBoxString(value: string): void {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // contracts/BoxStorage/contract.algo.ts:43
    // export default class BoxStorage extends Contract {
    txna ApplicationArgs 1
    extract 2 0
    // contracts/BoxStorage/contract.algo.ts:170
    // public setBoxString(value: string): void {
    callsub setBoxString
    intc_0 // 1
    return

main_setBox_route@13:
    // contracts/BoxStorage/contract.algo.ts:162
    // public setBox(valueInt: uint64): void {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // contracts/BoxStorage/contract.algo.ts:43
    // export default class BoxStorage extends Contract {
    txna ApplicationArgs 1
    btoi
    // contracts/BoxStorage/contract.algo.ts:162
    // public setBox(valueInt: uint64): void {
    callsub setBox
    intc_0 // 1
    return

main_maybeBoxRef_route@12:
    // contracts/BoxStorage/contract.algo.ts:149
    // @abimethod({ readonly: true })
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // contracts/BoxStorage/contract.algo.ts:43
    // export default class BoxStorage extends Contract {
    txna ApplicationArgs 1
    extract 2 0
    // contracts/BoxStorage/contract.algo.ts:149
    // @abimethod({ readonly: true })
    callsub maybeBoxRef
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return

main_boxMapExists_route@11:
    // contracts/BoxStorage/contract.algo.ts:140
    // @abimethod({ readonly: true })
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // contracts/BoxStorage/contract.algo.ts:43
    // export default class BoxStorage extends Contract {
    txna ApplicationArgs 1
    btoi
    // contracts/BoxStorage/contract.algo.ts:140
    // @abimethod({ readonly: true })
    callsub boxMapExists
    bytec_2 // 0x00
    intc_1 // 0
    uncover 2
    setbit
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return

main_getBoxRef_route@10:
    // contracts/BoxStorage/contract.algo.ts:126
    // public getBoxRef(): Account {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    callsub getBoxRef
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return

main_keyPrefixBoxMap_route@9:
    // contracts/BoxStorage/contract.algo.ts:117
    // @abimethod({ readonly: true })
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    pushbytes 0x151f7c750006626f784d6170
    log
    intc_0 // 1
    return

main_maybeBoxMap_route@8:
    // contracts/BoxStorage/contract.algo.ts:107
    // @abimethod({ readonly: true })
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // contracts/BoxStorage/contract.algo.ts:43
    // export default class BoxStorage extends Contract {
    txna ApplicationArgs 1
    btoi
    // contracts/BoxStorage/contract.algo.ts:107
    // @abimethod({ readonly: true })
    callsub maybeBoxMap
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return

main_getBoxMapWithDefault_route@7:
    // contracts/BoxStorage/contract.algo.ts:97
    // @abimethod({ readonly: true })
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // contracts/BoxStorage/contract.algo.ts:43
    // export default class BoxStorage extends Contract {
    txna ApplicationArgs 1
    btoi
    // contracts/BoxStorage/contract.algo.ts:97
    // @abimethod({ readonly: true })
    callsub getBoxMapWithDefault
    dup
    len
    itob
    extract 6 2
    swap
    concat
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return

main_getBoxMap_route@6:
    // contracts/BoxStorage/contract.algo.ts:87
    // @abimethod({ readonly: true })
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // contracts/BoxStorage/contract.algo.ts:43
    // export default class BoxStorage extends Contract {
    txna ApplicationArgs 1
    btoi
    // contracts/BoxStorage/contract.algo.ts:87
    // @abimethod({ readonly: true })
    callsub getBoxMap
    dup
    len
    itob
    extract 6 2
    swap
    concat
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return

main_maybeBox_route@5:
    // contracts/BoxStorage/contract.algo.ts:76
    // @abimethod({ readonly: true })
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    callsub maybeBox
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return

main_valueBox_route@4:
    // contracts/BoxStorage/contract.algo.ts:67
    // @abimethod({ readonly: true })
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    callsub valueBox
    itob
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return

main_getBox_route@3:
    // contracts/BoxStorage/contract.algo.ts:59
    // @abimethod({ readonly: true })
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    callsub getBox
    itob
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return

main_bare_routing@31:
    // contracts/BoxStorage/contract.algo.ts:43
    // export default class BoxStorage extends Contract {
    txn OnCompletion
    bnz main_after_if_else@35
    txn ApplicationID
    !
    assert // can only call when creating
    intc_0 // 1
    return


// contracts/BoxStorage/contract.algo.ts::BoxStorage.getBox() -> uint64:
getBox:
    // contracts/BoxStorage/contract.algo.ts:46
    // public boxInt = Box<uint64>({ key: 'boxInt' })
    bytec_3 // "boxInt"
    // contracts/BoxStorage/contract.algo.ts:61
    // return this.boxInt.value
    box_get
    assert // Box must have value
    btoi
    retsub


// contracts/BoxStorage/contract.algo.ts::BoxStorage.valueBox() -> uint64:
valueBox:
    // contracts/BoxStorage/contract.algo.ts:46
    // public boxInt = Box<uint64>({ key: 'boxInt' })
    bytec_3 // "boxInt"
    // contracts/BoxStorage/contract.algo.ts:69
    // return this.boxInt.value
    box_get
    assert // Box must have value
    btoi
    retsub


// contracts/BoxStorage/contract.algo.ts::BoxStorage.maybeBox() -> bytes:
maybeBox:
    // contracts/BoxStorage/contract.algo.ts:46
    // public boxInt = Box<uint64>({ key: 'boxInt' })
    bytec_3 // "boxInt"
    // contracts/BoxStorage/contract.algo.ts:78
    // const [boxIntValue, boxIntExists] = this.boxInt.maybe()
    box_get
    swap
    btoi
    // contracts/BoxStorage/contract.algo.ts:79
    // return [boxIntValue, boxIntExists]
    itob
    bytec_2 // 0x00
    intc_1 // 0
    uncover 3
    setbit
    concat
    retsub


// contracts/BoxStorage/contract.algo.ts::BoxStorage.getBoxMap(key: uint64) -> bytes:
getBoxMap:
    // contracts/BoxStorage/contract.algo.ts:87-88
    // @abimethod({ readonly: true })
    // public getBoxMap(key: uint64): string {
    proto 1 1
    // contracts/BoxStorage/contract.algo.ts:89
    // return this.boxMap(key).value
    frame_dig -1
    itob
    // contracts/BoxStorage/contract.algo.ts:50
    // public boxMap = BoxMap<uint64, string>({ keyPrefix: 'boxMap' })
    bytec_1 // "boxMap"
    swap
    concat
    // contracts/BoxStorage/contract.algo.ts:89
    // return this.boxMap(key).value
    box_get
    assert // Box must have value
    retsub


// contracts/BoxStorage/contract.algo.ts::BoxStorage.getBoxMapWithDefault(key: uint64) -> bytes:
getBoxMapWithDefault:
    // contracts/BoxStorage/contract.algo.ts:97-98
    // @abimethod({ readonly: true })
    // public getBoxMapWithDefault(key: uint64): string {
    proto 1 1
    // contracts/BoxStorage/contract.algo.ts:99
    // return this.boxMap(key).get({ default: 'default' })
    frame_dig -1
    itob
    // contracts/BoxStorage/contract.algo.ts:50
    // public boxMap = BoxMap<uint64, string>({ keyPrefix: 'boxMap' })
    bytec_1 // "boxMap"
    swap
    concat
    // contracts/BoxStorage/contract.algo.ts:99
    // return this.boxMap(key).get({ default: 'default' })
    box_get
    pushbytes "default"
    cover 2
    select
    retsub


// contracts/BoxStorage/contract.algo.ts::BoxStorage.maybeBoxMap(key: uint64) -> bytes:
maybeBoxMap:
    // contracts/BoxStorage/contract.algo.ts:107-108
    // @abimethod({ readonly: true })
    // public maybeBoxMap(key: uint64): [string, boolean] {
    proto 1 1
    // contracts/BoxStorage/contract.algo.ts:109
    // const [value, exists] = this.boxMap(key).maybe()
    frame_dig -1
    itob
    // contracts/BoxStorage/contract.algo.ts:50
    // public boxMap = BoxMap<uint64, string>({ keyPrefix: 'boxMap' })
    bytec_1 // "boxMap"
    swap
    concat
    // contracts/BoxStorage/contract.algo.ts:109
    // const [value, exists] = this.boxMap(key).maybe()
    box_get
    dup
    uncover 2
    swap
    // contracts/BoxStorage/contract.algo.ts:110
    // return [exists ? value : '', exists]
    bz maybeBoxMap_ternary_false@2
    frame_dig 1

maybeBoxMap_ternary_merge@3:
    // contracts/BoxStorage/contract.algo.ts:110
    // return [exists ? value : '', exists]
    dup
    len
    itob
    extract 6 2
    swap
    concat
    bytec_2 // 0x00
    intc_1 // 0
    frame_dig 0
    setbit
    bytec 9 // 0x0003
    swap
    concat
    swap
    concat
    frame_bury 0
    retsub

maybeBoxMap_ternary_false@2:
    // contracts/BoxStorage/contract.algo.ts:110
    // return [exists ? value : '', exists]
    pushbytes ""
    b maybeBoxMap_ternary_merge@3


// contracts/BoxStorage/contract.algo.ts::BoxStorage.getBoxRef() -> bytes:
getBoxRef:
    // contracts/BoxStorage/contract.algo.ts:49
    // public boxRef = BoxRef({ key: 'boxRef' })
    bytec 10 // "boxRef"
    // contracts/BoxStorage/contract.algo.ts:127
    // this.boxRef.create({ size: 32 })
    intc_2 // 32
    box_create
    pop
    // contracts/BoxStorage/contract.algo.ts:128
    // const senderBytes = Txn.sender.bytes
    txn Sender
    // contracts/BoxStorage/contract.algo.ts:129
    // this.boxRef.put(Txn.sender.bytes)
    dup
    // contracts/BoxStorage/contract.algo.ts:49
    // public boxRef = BoxRef({ key: 'boxRef' })
    bytec 10 // "boxRef"
    // contracts/BoxStorage/contract.algo.ts:129
    // this.boxRef.put(Txn.sender.bytes)
    dig 1
    box_put
    // contracts/BoxStorage/contract.algo.ts:131
    // assert(value === senderBytes, 'boxRef value mismatch')
    dup
    uncover 2
    ==
    assert // boxRef value mismatch
    // contracts/BoxStorage/contract.algo.ts:132
    // return Account(value)
    retsub


// contracts/BoxStorage/contract.algo.ts::BoxStorage.boxMapExists(key: uint64) -> uint64:
boxMapExists:
    // contracts/BoxStorage/contract.algo.ts:140-141
    // @abimethod({ readonly: true })
    // public boxMapExists(key: uint64): boolean {
    proto 1 1
    // contracts/BoxStorage/contract.algo.ts:142
    // return this.boxMap(key).exists
    frame_dig -1
    itob
    // contracts/BoxStorage/contract.algo.ts:50
    // public boxMap = BoxMap<uint64, string>({ keyPrefix: 'boxMap' })
    bytec_1 // "boxMap"
    swap
    concat
    // contracts/BoxStorage/contract.algo.ts:142
    // return this.boxMap(key).exists
    box_len
    bury 1
    retsub


// contracts/BoxStorage/contract.algo.ts::BoxStorage.maybeBoxRef(key: bytes) -> bytes:
maybeBoxRef:
    // contracts/BoxStorage/contract.algo.ts:149-150
    // @abimethod({ readonly: true })
    // public maybeBoxRef(key: string): [bytes, boolean] {
    proto 1 1
    // contracts/BoxStorage/contract.algo.ts:152
    // const [value, exists] = boxRef.maybe()
    frame_dig -1
    box_get
    // contracts/BoxStorage/contract.algo.ts:153
    // return [value, exists]
    dig 1
    len
    itob
    extract 6 2
    uncover 2
    concat
    bytec_2 // 0x00
    intc_1 // 0
    uncover 3
    setbit
    bytec 9 // 0x0003
    swap
    concat
    swap
    concat
    retsub


// contracts/BoxStorage/contract.algo.ts::BoxStorage.setBox(valueInt: uint64) -> void:
setBox:
    // contracts/BoxStorage/contract.algo.ts:162
    // public setBox(valueInt: uint64): void {
    proto 1 0
    // contracts/BoxStorage/contract.algo.ts:163
    // this.boxInt.value = valueInt
    frame_dig -1
    itob
    // contracts/BoxStorage/contract.algo.ts:46
    // public boxInt = Box<uint64>({ key: 'boxInt' })
    bytec_3 // "boxInt"
    // contracts/BoxStorage/contract.algo.ts:163
    // this.boxInt.value = valueInt
    swap
    box_put
    retsub


// contracts/BoxStorage/contract.algo.ts::BoxStorage.setBoxString(value: bytes) -> void:
setBoxString:
    // contracts/BoxStorage/contract.algo.ts:170
    // public setBoxString(value: string): void {
    proto 1 0
    // contracts/BoxStorage/contract.algo.ts:45
    // public boxString = Box<string>({ key: 'boxString' })
    bytec 5 // "boxString"
    // contracts/BoxStorage/contract.algo.ts:171
    // this.boxString.value = value
    box_del
    pop
    // contracts/BoxStorage/contract.algo.ts:45
    // public boxString = Box<string>({ key: 'boxString' })
    bytec 5 // "boxString"
    // contracts/BoxStorage/contract.algo.ts:171
    // this.boxString.value = value
    frame_dig -1
    box_put
    retsub


// contracts/BoxStorage/contract.algo.ts::BoxStorage.setBoxDynamicBytes(value: bytes) -> void:
setBoxDynamicBytes:
    // contracts/BoxStorage/contract.algo.ts:178
    // public setBoxDynamicBytes(value: arc4.DynamicBytes): void {
    proto 1 0
    // contracts/BoxStorage/contract.algo.ts:48
    // public boxDynamicBytes = Box<arc4.DynamicBytes>({ key: 'boxDynamicBytes' })
    bytec 6 // "boxDynamicBytes"
    // contracts/BoxStorage/contract.algo.ts:179
    // this.boxDynamicBytes.value = value
    box_del
    pop
    // contracts/BoxStorage/contract.algo.ts:48
    // public boxDynamicBytes = Box<arc4.DynamicBytes>({ key: 'boxDynamicBytes' })
    bytec 6 // "boxDynamicBytes"
    // contracts/BoxStorage/contract.algo.ts:179
    // this.boxDynamicBytes.value = value
    frame_dig -1
    box_put
    retsub


// contracts/BoxStorage/contract.algo.ts::BoxStorage.setBoxMap(key: uint64, value: bytes) -> void:
setBoxMap:
    // contracts/BoxStorage/contract.algo.ts:187
    // public setBoxMap(key: uint64, value: string): void {
    proto 2 0
    // contracts/BoxStorage/contract.algo.ts:188
    // this.boxMap(key).value = value
    frame_dig -2
    itob
    // contracts/BoxStorage/contract.algo.ts:50
    // public boxMap = BoxMap<uint64, string>({ keyPrefix: 'boxMap' })
    bytec_1 // "boxMap"
    swap
    concat
    // contracts/BoxStorage/contract.algo.ts:188
    // this.boxMap(key).value = value
    dup
    box_del
    pop
    frame_dig -1
    box_put
    retsub


// contracts/BoxStorage/contract.algo.ts::BoxStorage.setBoxRef(key: bytes) -> void:
setBoxRef:
    // contracts/BoxStorage/contract.algo.ts:195
    // public setBoxRef(key: string): void {
    proto 1 0
    // contracts/BoxStorage/contract.algo.ts:197
    // boxRef.create({ size: 32 })
    frame_dig -1
    intc_2 // 32
    box_create
    pop
    // contracts/BoxStorage/contract.algo.ts:199
    // boxRef.put(senderBytes)
    frame_dig -1
    // contracts/BoxStorage/contract.algo.ts:198
    // const senderBytes = Txn.sender.bytes
    txn Sender
    // contracts/BoxStorage/contract.algo.ts:199
    // boxRef.put(senderBytes)
    box_put
    retsub


// contracts/BoxStorage/contract.algo.ts::BoxStorage.boxMapLength(key: uint64) -> uint64:
boxMapLength:
    // contracts/BoxStorage/contract.algo.ts:209-210
    // @abimethod({ readonly: true })
    // public boxMapLength(key: uint64): uint64 {
    proto 1 1
    // contracts/BoxStorage/contract.algo.ts:211
    // if (!this.boxMap(key).exists) {
    frame_dig -1
    itob
    // contracts/BoxStorage/contract.algo.ts:50
    // public boxMap = BoxMap<uint64, string>({ keyPrefix: 'boxMap' })
    bytec_1 // "boxMap"
    swap
    concat
    dup
    // contracts/BoxStorage/contract.algo.ts:211
    // if (!this.boxMap(key).exists) {
    box_len
    bury 1
    bnz boxMapLength_after_if_else@2
    // contracts/BoxStorage/contract.algo.ts:212
    // return Uint64(0)
    intc_1 // 0
    swap
    retsub

boxMapLength_after_if_else@2:
    // contracts/BoxStorage/contract.algo.ts:215
    // return this.boxMap(key).length
    frame_dig 0
    box_len
    assert // Box must have value
    swap
    retsub


// contracts/BoxStorage/contract.algo.ts::BoxStorage.lengthBoxRef(key: bytes) -> uint64:
lengthBoxRef:
    // contracts/BoxStorage/contract.algo.ts:223
    // public lengthBoxRef(key: string): uint64 {
    proto 1 1
    // contracts/BoxStorage/contract.algo.ts:225
    // assert(boxRef.create({ size: 32 }), 'boxRef creation failed')
    frame_dig -1
    intc_2 // 32
    box_create
    assert // boxRef creation failed
    // contracts/BoxStorage/contract.algo.ts:226
    // return boxRef.length
    frame_dig -1
    box_len
    pop
    retsub


// contracts/BoxStorage/contract.algo.ts::BoxStorage.deleteBox() -> void:
deleteBox:
    // contracts/BoxStorage/contract.algo.ts:46
    // public boxInt = Box<uint64>({ key: 'boxInt' })
    bytec_3 // "boxInt"
    // contracts/BoxStorage/contract.algo.ts:235
    // this.boxInt.delete()
    box_del
    pop
    // contracts/BoxStorage/contract.algo.ts:48
    // public boxDynamicBytes = Box<arc4.DynamicBytes>({ key: 'boxDynamicBytes' })
    bytec 6 // "boxDynamicBytes"
    // contracts/BoxStorage/contract.algo.ts:236
    // this.boxDynamicBytes.delete()
    box_del
    pop
    // contracts/BoxStorage/contract.algo.ts:45
    // public boxString = Box<string>({ key: 'boxString' })
    bytec 5 // "boxString"
    // contracts/BoxStorage/contract.algo.ts:237
    // this.boxString.delete()
    box_del
    pop
    // contracts/BoxStorage/contract.algo.ts:46
    // public boxInt = Box<uint64>({ key: 'boxInt' })
    bytec_3 // "boxInt"
    // contracts/BoxStorage/contract.algo.ts:239
    // assert(this.boxInt.get({ default: Uint64(42) }) === 42)
    box_get
    swap
    btoi
    pushint 42 // 42
    swap
    uncover 2
    select
    pushint 42 // 42
    ==
    assert
    // contracts/BoxStorage/contract.algo.ts:48
    // public boxDynamicBytes = Box<arc4.DynamicBytes>({ key: 'boxDynamicBytes' })
    bytec 6 // "boxDynamicBytes"
    // contracts/BoxStorage/contract.algo.ts:240
    // assert(this.boxDynamicBytes.get({ default: new arc4.DynamicBytes('42') }).native === Bytes('42'))
    box_get
    pushbytes 0x00023432
    cover 2
    select
    extract 2 0
    bytec 8 // "42"
    ==
    assert
    // contracts/BoxStorage/contract.algo.ts:45
    // public boxString = Box<string>({ key: 'boxString' })
    bytec 5 // "boxString"
    // contracts/BoxStorage/contract.algo.ts:241
    // assert(this.boxString.get({ default: '42' }) === '42')
    box_get
    bytec 8 // "42"
    cover 2
    select
    bytec 8 // "42"
    ==
    assert
    retsub


// contracts/BoxStorage/contract.algo.ts::BoxStorage.deleteBoxMap(key: uint64) -> void:
deleteBoxMap:
    // contracts/BoxStorage/contract.algo.ts:248
    // public deleteBoxMap(key: uint64): void {
    proto 1 0
    // contracts/BoxStorage/contract.algo.ts:249
    // this.boxMap(key).delete()
    frame_dig -1
    itob
    // contracts/BoxStorage/contract.algo.ts:50
    // public boxMap = BoxMap<uint64, string>({ keyPrefix: 'boxMap' })
    bytec_1 // "boxMap"
    swap
    concat
    // contracts/BoxStorage/contract.algo.ts:249
    // this.boxMap(key).delete()
    box_del
    pop
    retsub


// contracts/BoxStorage/contract.algo.ts::BoxStorage.deleteBoxRef(key: bytes) -> void:
deleteBoxRef:
    // contracts/BoxStorage/contract.algo.ts:256
    // public deleteBoxRef(key: string): void {
    proto 1 0
    // contracts/BoxStorage/contract.algo.ts:258
    // boxRef.delete()
    frame_dig -1
    box_del
    pop
    // contracts/BoxStorage/contract.algo.ts:259
    // assertMatch(boxRef.maybe(), [Bytes(''), false])
    frame_dig -1
    box_get
    pop
    pushbytes ""
    ==
    intc_0 // 1
    &&
    frame_dig -1
    box_len
    bury 1
    !
    &&
    assert // assert target is match for conditions
    retsub


// contracts/BoxStorage/contract.algo.ts::BoxStorage.extractBoxRef(key: bytes) -> void:
extractBoxRef:
    // contracts/BoxStorage/contract.algo.ts:268
    // public extractBoxRef(key: string): void {
    proto 1 0
    // contracts/BoxStorage/contract.algo.ts:269
    // const senderBytes = Txn.sender.bytes
    txn Sender
    // contracts/BoxStorage/contract.algo.ts:270
    // const appAddress = Global.currentApplicationAddress.bytes
    global CurrentApplicationAddress
    // contracts/BoxStorage/contract.algo.ts:275
    // assert(boxRef.create({ size: totalSize }), 'boxRef creation failed')
    frame_dig -1
    // contracts/BoxStorage/contract.algo.ts:272
    // const totalSize = Uint64(appAddress.length + senderBytes.length)
    pushint 64 // 64
    // contracts/BoxStorage/contract.algo.ts:275
    // assert(boxRef.create({ size: totalSize }), 'boxRef creation failed')
    box_create
    assert // boxRef creation failed
    // contracts/BoxStorage/contract.algo.ts:277
    // boxRef.replace(0, senderBytes)
    frame_dig -1
    intc_1 // 0
    dig 3
    box_replace
    // contracts/BoxStorage/contract.algo.ts:278
    // boxRef.splice(0, 0, appAddress)
    frame_dig -1
    intc_1 // 0
    dup
    dig 3
    box_splice
    // contracts/BoxStorage/contract.algo.ts:280
    // const part1 = boxRef.extract(0, 32)
    frame_dig -1
    intc_1 // 0
    intc_2 // 32
    box_extract
    // contracts/BoxStorage/contract.algo.ts:281
    // const part2 = boxRef.extract(32, 32)
    frame_dig -1
    intc_2 // 32
    dup
    box_extract
    // contracts/BoxStorage/contract.algo.ts:283
    // assert(part1.equals(appAddress), 'First part should match app address')
    swap
    uncover 2
    ==
    assert // First part should match app address
    // contracts/BoxStorage/contract.algo.ts:284
    // assert(part2.equals(senderBytes), 'Second part should match sender bytes')
    ==
    assert // Second part should match sender bytes
    retsub


// contracts/BoxStorage/contract.algo.ts::BoxStorage.getBoxMapObject(key: uint64) -> bytes:
getBoxMapObject:
    // contracts/BoxStorage/contract.algo.ts:294-295
    // @abimethod({ readonly: true })
    // public getBoxMapObject(key: uint64): User {
    proto 1 1
    // contracts/BoxStorage/contract.algo.ts:296
    // return this.boxMapObject(key).value
    frame_dig -1
    itob
    // contracts/BoxStorage/contract.algo.ts:51
    // public boxMapObject = BoxMap<uint64, User>({ keyPrefix: 'users' })
    bytec 7 // "users"
    swap
    concat
    // contracts/BoxStorage/contract.algo.ts:296
    // return this.boxMapObject(key).value
    box_get
    assert // Box must have value
    retsub


// contracts/BoxStorage/contract.algo.ts::BoxStorage.boxMapObjectExists(key: uint64) -> uint64:
boxMapObjectExists:
    // contracts/BoxStorage/contract.algo.ts:304-305
    // @abimethod({ readonly: true })
    // public boxMapObjectExists(key: uint64): boolean {
    proto 1 1
    // contracts/BoxStorage/contract.algo.ts:306
    // return this.boxMapObject(key).exists
    frame_dig -1
    itob
    // contracts/BoxStorage/contract.algo.ts:51
    // public boxMapObject = BoxMap<uint64, User>({ keyPrefix: 'users' })
    bytec 7 // "users"
    swap
    concat
    // contracts/BoxStorage/contract.algo.ts:306
    // return this.boxMapObject(key).exists
    box_len
    bury 1
    retsub


// contracts/BoxStorage/contract.algo.ts::BoxStorage.setBoxMapObject(key: uint64, value: bytes) -> uint64:
setBoxMapObject:
    // contracts/BoxStorage/contract.algo.ts:314
    // public setBoxMapObject(key: uint64, value: User): boolean {
    proto 2 1
    // contracts/BoxStorage/contract.algo.ts:315
    // this.boxMapObject(key).value = clone(value)
    frame_dig -2
    itob
    // contracts/BoxStorage/contract.algo.ts:51
    // public boxMapObject = BoxMap<uint64, User>({ keyPrefix: 'users' })
    bytec 7 // "users"
    swap
    concat
    // contracts/BoxStorage/contract.algo.ts:315
    // this.boxMapObject(key).value = clone(value)
    dup
    box_del
    pop
    dup
    frame_dig -1
    box_put
    // contracts/BoxStorage/contract.algo.ts:316-324
    // assertMatch(
    //   this.boxMapObject(key).value,
    //   {
    //     name: value.name,
    //     id: value.id,
    //     asset: value.asset,
    //   },
    //   'boxMapObject value mismatch',
    // )
    dup
    intc_3 // 2
    pushint 8 // 8
    box_extract
    btoi
    // contracts/BoxStorage/contract.algo.ts:320
    // id: value.id,
    frame_dig -1
    intc_3 // 2
    extract_uint64
    // contracts/BoxStorage/contract.algo.ts:316-324
    // assertMatch(
    //   this.boxMapObject(key).value,
    //   {
    //     name: value.name,
    //     id: value.id,
    //     asset: value.asset,
    //   },
    //   'boxMapObject value mismatch',
    // )
    ==
    intc_0 // 1
    &&
    swap
    pushints 10 8 // 10, 8
    box_extract
    btoi
    // contracts/BoxStorage/contract.algo.ts:321
    // asset: value.asset,
    frame_dig -1
    pushint 10 // 10
    extract_uint64
    // contracts/BoxStorage/contract.algo.ts:316-324
    // assertMatch(
    //   this.boxMapObject(key).value,
    //   {
    //     name: value.name,
    //     id: value.id,
    //     asset: value.asset,
    //   },
    //   'boxMapObject value mismatch',
    // )
    ==
    &&
    assert // boxMapObject value mismatch
    // contracts/BoxStorage/contract.algo.ts:325
    // return true
    intc_0 // 1
    retsub


// contracts/BoxStorage/contract.algo.ts::BoxStorage.boxMapObjectLength(key: uint64) -> uint64:
boxMapObjectLength:
    // contracts/BoxStorage/contract.algo.ts:333
    // public boxMapObjectLength(key: uint64): uint64 {
    proto 1 1
    // contracts/BoxStorage/contract.algo.ts:340
    // this.boxMapObject(key).value = clone(value)
    frame_dig -1
    itob
    // contracts/BoxStorage/contract.algo.ts:51
    // public boxMapObject = BoxMap<uint64, User>({ keyPrefix: 'users' })
    bytec 7 // "users"
    swap
    concat
    // contracts/BoxStorage/contract.algo.ts:340
    // this.boxMapObject(key).value = clone(value)
    dup
    box_del
    pop
    dup
    pushbytes 0x0012000000000000004600000000000004d20008746573744e616d65
    box_put
    // contracts/BoxStorage/contract.algo.ts:342
    // return this.boxMapObject(key).length
    box_len
    pop
    retsub


// contracts/BoxStorage/contract.algo.ts::BoxStorage.arc4Box(key: bytes) -> bytes:
arc4Box:
    // contracts/BoxStorage/contract.algo.ts:352
    // public arc4Box(key: string): Uint8x4 {
    proto 1 1
    // contracts/BoxStorage/contract.algo.ts:355
    // staticIntBox.value = new FixedArray<arc4.Uint8, 4>(new Uint8(0), new Uint8(1), new Uint8(2), new Uint8(3))
    frame_dig -1
    bytec 4 // 0x00010203
    box_put
    bytec 4 // 0x00010203
    // contracts/BoxStorage/contract.algo.ts:357
    // assert(staticIntBox.value[0].native === 0)
    intc_1 // 0
    getbyte
    !
    assert
    // contracts/BoxStorage/contract.algo.ts:355
    // staticIntBox.value = new FixedArray<arc4.Uint8, 4>(new Uint8(0), new Uint8(1), new Uint8(2), new Uint8(3))
    bytec 4 // 0x00010203
    // contracts/BoxStorage/contract.algo.ts:358
    // assert(staticIntBox.value[1].native === 1)
    intc_0 // 1
    getbyte
    intc_0 // 1
    ==
    assert
    // contracts/BoxStorage/contract.algo.ts:355
    // staticIntBox.value = new FixedArray<arc4.Uint8, 4>(new Uint8(0), new Uint8(1), new Uint8(2), new Uint8(3))
    bytec 4 // 0x00010203
    // contracts/BoxStorage/contract.algo.ts:359
    // assert(staticIntBox.value[2].native === 2)
    intc_3 // 2
    getbyte
    intc_3 // 2
    ==
    assert
    // contracts/BoxStorage/contract.algo.ts:355
    // staticIntBox.value = new FixedArray<arc4.Uint8, 4>(new Uint8(0), new Uint8(1), new Uint8(2), new Uint8(3))
    bytec 4 // 0x00010203
    // contracts/BoxStorage/contract.algo.ts:360
    // assert(staticIntBox.value[3].native === 3)
    pushint 3 // 3
    getbyte
    pushint 3 // 3
    ==
    assert
    // contracts/BoxStorage/contract.algo.ts:355
    // staticIntBox.value = new FixedArray<arc4.Uint8, 4>(new Uint8(0), new Uint8(1), new Uint8(2), new Uint8(3))
    bytec 4 // 0x00010203
    // contracts/BoxStorage/contract.algo.ts:362
    // return staticIntBox.value
    retsub
