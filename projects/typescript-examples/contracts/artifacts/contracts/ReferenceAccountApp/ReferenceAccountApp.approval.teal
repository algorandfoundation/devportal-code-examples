#pragma version 11
#pragma typetrack false

// @algorandfoundation/algorand-typescript/arc4/index.d.ts::Contract.approvalProgram() -> uint64:
main:
    intcblock 0 1
    bytecblock "my_counter" 0x151f7c75
    // contracts/ReferenceAccountApp/contract.algo.ts:51
    // export default class ReferenceAccountApp extends Contract {
    txn NumAppArgs
    bz main___algots__.defaultCreate@9
    txn OnCompletion
    !
    assert // OnCompletion must be NoOp
    txn ApplicationID
    assert
    pushbytess 0x87ad70bf 0x605c4419 // method "getMyCounter()uint64", method "getMyCounterWithArg(address,uint64)uint64"
    txna ApplicationArgs 0
    match getMyCounter getMyCounterWithArg
    err

main___algots__.defaultCreate@9:
    // contracts/ReferenceAccountApp/contract.algo.ts:51
    // export default class ReferenceAccountApp extends Contract {
    txn OnCompletion
    !
    txn ApplicationID
    !
    &&
    return // on error: OnCompletion must be NoOp && can only call when creating


// contracts/ReferenceAccountApp/contract.algo.ts::ReferenceAccountApp.getMyCounter[routing]() -> void:
getMyCounter:
    // contracts/ReferenceAccountApp/contract.algo.ts:59
    // const addressBytes = address.bytes
    pushbytes base32(WMHF4FLJNKY2BPFK7YPV5ID6OZ7LVDB2B66ZTXEAMLL2NX4WJZRA) // addr WMHF4FLJNKY2BPFK7YPV5ID6OZ7LVDB2B66ZTXEAMLL2NX4WJZRJFVX66M
    // contracts/ReferenceAccountApp/contract.algo.ts:61
    // const app = Application(1717) // Replace with your application id
    pushint 1717 // 1717
    // contracts/ReferenceAccountApp/contract.algo.ts:64
    // const [value, hasValue] = op.AppLocal.getExUint64(account, app, Bytes('my_counter'))
    bytec_0 // "my_counter"
    app_local_get_ex
    // contracts/ReferenceAccountApp/contract.algo.ts:66
    // if (!hasValue) {
    bnz getMyCounter_after_if_else@3
    // contracts/ReferenceAccountApp/contract.algo.ts:67
    // return 0
    intc_0 // 0

getMyCounter_after_inlined_contracts/ReferenceAccountApp/contract.algo.ts::ReferenceAccountApp.getMyCounter@4:
    // contracts/ReferenceAccountApp/contract.algo.ts:56
    // @abimethod({ readonly: true })
    itob
    bytec_1 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

getMyCounter_after_if_else@3:
    dup
    // contracts/ReferenceAccountApp/contract.algo.ts:56
    // @abimethod({ readonly: true })
    b getMyCounter_after_inlined_contracts/ReferenceAccountApp/contract.algo.ts::ReferenceAccountApp.getMyCounter@4


// contracts/ReferenceAccountApp/contract.algo.ts::ReferenceAccountApp.getMyCounterWithArg[routing]() -> void:
getMyCounterWithArg:
    // contracts/ReferenceAccountApp/contract.algo.ts:79
    // @abimethod({ readonly: true })
    txna ApplicationArgs 1
    txna ApplicationArgs 2
    btoi
    // contracts/ReferenceAccountApp/contract.algo.ts:82
    // const [value, hasValue] = op.AppLocal.getExUint64(account, app, Bytes('my_counter'))
    bytec_0 // "my_counter"
    app_local_get_ex
    // contracts/ReferenceAccountApp/contract.algo.ts:84
    // if (!hasValue) {
    bnz getMyCounterWithArg_after_if_else@3
    // contracts/ReferenceAccountApp/contract.algo.ts:85
    // return 0
    intc_0 // 0

getMyCounterWithArg_after_inlined_contracts/ReferenceAccountApp/contract.algo.ts::ReferenceAccountApp.getMyCounterWithArg@4:
    // contracts/ReferenceAccountApp/contract.algo.ts:79
    // @abimethod({ readonly: true })
    itob
    bytec_1 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

getMyCounterWithArg_after_if_else@3:
    dup
    // contracts/ReferenceAccountApp/contract.algo.ts:79
    // @abimethod({ readonly: true })
    b getMyCounterWithArg_after_inlined_contracts/ReferenceAccountApp/contract.algo.ts::ReferenceAccountApp.getMyCounterWithArg@4
