#pragma version 11
#pragma typetrack false

// algopy.arc4.ARC4Contract.approval_program() -> uint64:
main:
    intcblock 1
    bytecblock 0x75736572730000000000000000 "users" 0x151f7c7580 0x151f7c75
    // smart_contracts/struct_in_box/contract.py:11
    // class StructInBoxMap(arc4.ARC4Contract):
    txn NumAppArgs
    bz main___algopy_default_create@13
    txn OnCompletion
    !
    assert // OnCompletion must be NoOp
    txn ApplicationID
    assert
    pushbytess 0xcaad1623 0x079c27bd 0x6a02b350 0x8ee2c364 // method "box_map_test()bool", method "box_map_set(uint64,(string,uint64,uint64))bool", method "box_map_get(uint64)(string,uint64,uint64)", method "box_map_exists(uint64)bool"
    txna ApplicationArgs 0
    match box_map_test box_map_set box_map_get box_map_exists
    err

main___algopy_default_create@13:
    txn OnCompletion
    !
    txn ApplicationID
    !
    &&
    return // on error: OnCompletion must be NoOp && can only call when creating


// smart_contracts.struct_in_box.contract.StructInBoxMap.box_map_test[routing]() -> void:
box_map_test:
    // smart_contracts/struct_in_box/contract.py:20
    // self.user_map[key_0] = value.copy()
    bytec_0 // 0x75736572730000000000000000
    box_del
    pop
    bytec_0 // 0x75736572730000000000000000
    // smart_contracts/struct_in_box/contract.py:18
    // value = UserStruct(arc4.String("testName"), arc4.UInt64(70), arc4.UInt64(2))
    pushbytes 0x0012000000000000004600000000000000020008746573744e616d65
    // smart_contracts/struct_in_box/contract.py:20
    // self.user_map[key_0] = value.copy()
    box_put
    // smart_contracts/struct_in_box/contract.py:21
    // assert self.user_map[key_0].bytes.length == value.bytes.length
    bytec_0 // 0x75736572730000000000000000
    box_len
    pop
    pushint 28 // 28
    ==
    assert
    // smart_contracts/struct_in_box/contract.py:15
    // @arc4.abimethod
    bytec_2 // 0x151f7c7580
    log
    intc_0 // 1
    return


// smart_contracts.struct_in_box.contract.StructInBoxMap.box_map_set[routing]() -> void:
box_map_set:
    // smart_contracts/struct_in_box/contract.py:25
    // @arc4.abimethod
    txna ApplicationArgs 2
    // smart_contracts/struct_in_box/contract.py:27
    // self.user_map[key] = value.copy()
    bytec_1 // "users"
    // smart_contracts/struct_in_box/contract.py:25
    // @arc4.abimethod
    txna ApplicationArgs 1
    // smart_contracts/struct_in_box/contract.py:27
    // self.user_map[key] = value.copy()
    concat
    dup
    box_del
    pop
    swap
    box_put
    // smart_contracts/struct_in_box/contract.py:25
    // @arc4.abimethod
    bytec_2 // 0x151f7c7580
    log
    intc_0 // 1
    return


// smart_contracts.struct_in_box.contract.StructInBoxMap.box_map_get[routing]() -> void:
box_map_get:
    // smart_contracts/struct_in_box/contract.py:33
    // return self.user_map[key]
    bytec_1 // "users"
    // smart_contracts/struct_in_box/contract.py:31
    // @arc4.abimethod
    txna ApplicationArgs 1
    // smart_contracts/struct_in_box/contract.py:33
    // return self.user_map[key]
    concat
    box_get
    assert // check self.user_map entry exists
    // smart_contracts/struct_in_box/contract.py:31
    // @arc4.abimethod
    bytec_3 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return


// smart_contracts.struct_in_box.contract.StructInBoxMap.box_map_exists[routing]() -> void:
box_map_exists:
    // smart_contracts/struct_in_box/contract.py:37
    // return key in self.user_map
    bytec_1 // "users"
    // smart_contracts/struct_in_box/contract.py:35
    // @arc4.abimethod
    txna ApplicationArgs 1
    // smart_contracts/struct_in_box/contract.py:37
    // return key in self.user_map
    concat
    box_len
    bury 1
    // smart_contracts/struct_in_box/contract.py:35
    // @arc4.abimethod
    pushbytes 0x00
    pushint 0 // 0
    uncover 2
    setbit
    bytec_3 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return
