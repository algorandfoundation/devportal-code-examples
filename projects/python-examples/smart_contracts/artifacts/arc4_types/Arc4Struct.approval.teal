#pragma version 11
#pragma typetrack false

// algopy.arc4.ARC4Contract.approval_program() -> uint64:
main:
    intcblock 0 2 1
    bytecblock "todos" 0x 0x0000 0x151f7c75
    txn ApplicationID
    bnz main_after_if_else@2
    // smart_contracts/arc4_types/contract.py:229
    // self.todos = Todos()
    bytec_0 // "todos"
    bytec_2 // 0x0000
    app_global_put

main_after_if_else@2:
    // smart_contracts/arc4_types/contract.py:227
    // class Arc4Struct(ARC4Contract):
    txn NumAppArgs
    bz main___algopy_default_create@12
    txn OnCompletion
    !
    assert // OnCompletion must be NoOp
    txn ApplicationID
    assert
    pushbytess 0xf618a255 0x11cfe2d8 0xea9e2d9d // method "add_todo(string)(string,bool)[]", method "complete_todo(string)void", method "return_todo(string)(string,bool)"
    txna ApplicationArgs 0
    match add_todo complete_todo return_todo
    err

main___algopy_default_create@12:
    txn OnCompletion
    !
    txn ApplicationID
    !
    &&
    return // on error: OnCompletion must be NoOp && can only call when creating


// smart_contracts.arc4_types.contract.Arc4Struct.add_todo[routing]() -> void:
add_todo:
    intc_0 // 0
    dupn 2
    bytec_1 // ""
    dupn 3
    // smart_contracts/arc4_types/contract.py:233
    // todo = Todo(task=task, completed=arc4.Bool(False))  # noqa: FBT003
    pushbytes 0x000300
    // smart_contracts/arc4_types/contract.py:231
    // @abimethod()
    txna ApplicationArgs 1
    // smart_contracts/arc4_types/contract.py:233
    // todo = Todo(task=task, completed=arc4.Bool(False))  # noqa: FBT003
    concat
    // smart_contracts/arc4_types/contract.py:235
    // if not self.todos:
    intc_0 // 0
    bytec_0 // "todos"
    app_global_get_ex
    assert // check self.todos exists
    bytec_2 // 0x0000
    ==
    bz add_todo_else_body@3
    // smart_contracts/arc4_types/contract.py:236
    // self.todos = Todos(todo.copy())
    pushbytes 0x00010002
    swap
    concat
    bytec_0 // "todos"
    swap
    app_global_put

add_todo_after_if_else@4:
    // smart_contracts/arc4_types/contract.py:240
    // return self.todos
    intc_0 // 0
    bytec_0 // "todos"
    app_global_get_ex
    assert // check self.todos exists
    // smart_contracts/arc4_types/contract.py:231
    // @abimethod()
    bytec_3 // 0x151f7c75
    swap
    concat
    log
    intc_2 // 1
    return

add_todo_else_body@3:
    // smart_contracts/arc4_types/contract.py:238
    // self.todos.append(todo.copy())
    intc_0 // 0
    bytec_0 // "todos"
    app_global_get_ex
    assert // check self.todos exists
    dup
    intc_0 // 0
    extract_uint16
    dup
    cover 2
    bury 7
    extract 2 0
    bury 9
    pushbytes 0x0002
    uncover 2
    concat
    bury 6
    bytec_1 // 0x
    bury 7
    intc_1 // 2
    *
    bury 1
    intc_0 // 0
    bury 2

add_todo_for_header@6:
    dup2
    <
    bz add_todo_after_for@8
    dig 6
    dig 2
    dup
    cover 2
    extract_uint16
    intc_1 // 2
    +
    itob
    extract 6 2
    dig 7
    swap
    concat
    bury 7
    intc_1 // 2
    +
    bury 2
    b add_todo_for_header@6

add_todo_after_for@8:
    dig 6
    len
    bury 3
    intc_0 // 0
    bury 2

add_todo_for_header@9:
    dig 1
    intc_1 // 2
    <
    bz add_todo_after_for@11
    dig 4
    dig 2
    dup
    cover 2
    extract_uint16
    dig 4
    +
    itob
    extract 6 2
    dig 7
    swap
    concat
    bury 7
    intc_1 // 2
    +
    bury 2
    b add_todo_for_header@9

add_todo_after_for@11:
    dig 3
    // smart_contracts/arc4_types/contract.py:238
    // self.todos.append(todo.copy())
    intc_2 // 1
    +
    itob
    extract 6 2
    dig 6
    concat
    dig 7
    dig 2
    dig 5
    substring3
    concat
    dig 5
    extract 2 0
    concat
    // smart_contracts/arc4_types/contract.py:238
    // self.todos.append(todo.copy())
    bytec_0 // "todos"
    swap
    app_global_put
    b add_todo_after_if_else@4


// smart_contracts.arc4_types.contract.Arc4Struct.complete_todo[routing]() -> void:
complete_todo:
    intc_0 // 0
    dup
    bytec_1 // ""
    dupn 5
    // smart_contracts/arc4_types/contract.py:242
    // @abimethod()
    txna ApplicationArgs 1
    // smart_contracts/arc4_types/contract.py:244
    // for index in urange(self.todos.length):
    intc_0 // 0
    bytec_0 // "todos"
    app_global_get_ex
    assert // check self.todos exists
    intc_0 // 0
    extract_uint16
    intc_0 // 0

complete_todo_for_header@2:
    // smart_contracts/arc4_types/contract.py:244
    // for index in urange(self.todos.length):
    dup
    dig 2
    <
    bz complete_todo_after_for@7
    // smart_contracts/arc4_types/contract.py:245
    // if self.todos[index].task == task:
    intc_0 // 0
    bytec_0 // "todos"
    app_global_get_ex
    assert // check self.todos exists
    dup
    extract 2 0
    swap
    intc_0 // 0
    extract_uint16
    dig 2
    dup
    intc_1 // 2
    *
    dup
    bury 13
    dig 3
    swap
    extract_uint16
    swap
    intc_2 // 1
    +
    dup
    cover 4
    uncover 2
    dig 1
    - // on error: index access is out of bounds
    dig 3
    len
    uncover 2
    intc_1 // 2
    *
    dup
    bury 14
    dig 4
    swap
    extract_uint16
    uncover 2
    select
    substring3
    dup
    intc_0 // 0
    extract_uint16
    dig 1
    len
    substring3
    dig 4
    ==
    bz complete_todo_after_if_else@5
    // smart_contracts/arc4_types/contract.py:246
    // self.todos[index].completed = arc4.Bool(True)  # noqa: FBT003
    intc_0 // 0
    bytec_0 // "todos"
    app_global_get_ex
    assert // check self.todos exists
    dup
    extract 2 0
    dig 1
    intc_0 // 0
    extract_uint16
    dig 1
    dig 13
    extract_uint16
    dig 1
    uncover 5
    - // on error: index access is out of bounds
    dig 3
    len
    dig 4
    dig 14
    dup
    cover 8
    extract_uint16
    dup2
    uncover 4
    select
    dig 5
    dig 4
    uncover 2
    substring3
    pushint 16 // 16
    intc_2 // 1
    setbit
    dig 8
    dup
    uncover 6
    <
    assert // index access is out of bounds
    uncover 6
    substring 0 2
    dup
    bury 18
    btoi
    dup
    uncover 2
    -
    intc_2 // 1
    -
    dig 4
    uncover 4
    uncover 2
    select
    dup
    dig 5
    -
    bury 12
    dig 2
    len
    bury 13
    dig 5
    intc_0 // 0
    uncover 6
    substring3
    uncover 3
    concat
    uncover 4
    uncover 2
    uncover 4
    substring3
    concat
    bury 13
    intc_1 // 2
    *
    bury 5
    bury 7

complete_todo_for_header@9:
    dig 6
    dig 4
    <
    bz complete_todo_after_for@11
    dig 10
    dup
    dig 8
    dup
    cover 3
    extract_uint16
    dig 8
    +
    dig 7
    -
    itob
    extract 6 2
    dig 2
    swap
    replace3
    bury 12
    intc_1 // 2
    +
    bury 7
    b complete_todo_for_header@9

complete_todo_after_for@11:
    dig 9
    dig 11
    concat
    // smart_contracts/arc4_types/contract.py:246
    // self.todos[index].completed = arc4.Bool(True)  # noqa: FBT003
    bytec_0 // "todos"
    swap
    app_global_put

complete_todo_after_for@7:
    // smart_contracts/arc4_types/contract.py:242
    // @abimethod()
    intc_2 // 1
    return

complete_todo_after_if_else@5:
    bury 1
    b complete_todo_for_header@2


// smart_contracts.arc4_types.contract.Arc4Struct.return_todo[routing]() -> void:
return_todo:
    bytec_1 // ""
    dupn 2
    // smart_contracts/arc4_types/contract.py:249
    // @abimethod()
    txna ApplicationArgs 1
    intc_0 // 0
    // smart_contracts/arc4_types/contract.py:253-254
    // exist = False
    // for index in urange(self.todos.length):
    dupn 2
    // smart_contracts/arc4_types/contract.py:254
    // for index in urange(self.todos.length):
    bytec_0 // "todos"
    app_global_get_ex
    assert // check self.todos exists
    intc_0 // 0
    extract_uint16
    intc_0 // 0

return_todo_for_header@2:
    // smart_contracts/arc4_types/contract.py:254
    // for index in urange(self.todos.length):
    dup
    dig 2
    <
    bz return_todo_after_for@7
    // smart_contracts/arc4_types/contract.py:255
    // if self.todos[index].task == task:
    intc_0 // 0
    bytec_0 // "todos"
    app_global_get_ex
    assert // check self.todos exists
    dup
    extract 2 0
    swap
    intc_0 // 0
    extract_uint16
    dig 2
    dup
    intc_1 // 2
    *
    dup
    bury 12
    dig 3
    swap
    extract_uint16
    swap
    intc_2 // 1
    +
    dup
    bury 11
    uncover 2
    dig 1
    - // on error: index access is out of bounds
    dig 3
    len
    uncover 2
    intc_1 // 2
    *
    dup
    bury 11
    dig 4
    swap
    extract_uint16
    uncover 2
    select
    substring3
    dup
    intc_0 // 0
    extract_uint16
    dig 1
    len
    substring3
    dig 5
    ==
    bz return_todo_after_if_else@5
    // smart_contracts/arc4_types/contract.py:256
    // todo_to_return = self.todos[index].copy()
    intc_0 // 0
    bytec_0 // "todos"
    app_global_get_ex
    assert // check self.todos exists
    dup
    extract 2 0
    swap
    intc_0 // 0
    extract_uint16
    dig 1
    dig 10
    extract_uint16
    swap
    dig 9
    - // on error: index access is out of bounds
    dig 2
    len
    dig 3
    dig 10
    extract_uint16
    uncover 2
    select
    substring3
    bury 4
    // smart_contracts/arc4_types/contract.py:257
    // exist = True
    intc_2 // 1
    bury 3

return_todo_after_if_else@5:
    dig 6
    bury 1
    b return_todo_for_header@2

return_todo_after_for@7:
    // smart_contracts/arc4_types/contract.py:259
    // assert exist
    dig 2
    assert
    // smart_contracts/arc4_types/contract.py:249
    // @abimethod()
    bytec_3 // 0x151f7c75
    dig 4
    concat
    log
    intc_2 // 1
    return
