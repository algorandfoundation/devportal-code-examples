#pragma version 11
#pragma typetrack false

// algopy.arc4.ARC4Contract.approval_program() -> uint64:
main:
    intcblock 1 0
    bytecblock "my_counter"
    // smart_contracts/reference_account_app/contract.py:20
    // class MyCounter(ARC4Contract):
    txn NumAppArgs
    bz main___algopy_default_create@8
    pushbytess 0x30c6d58a 0x856a1202 // method "opt_in()void", method "increment_my_counter()uint64"
    txna ApplicationArgs 0
    match main_opt_in_route@5 main_increment_my_counter_route@6
    err

main_increment_my_counter_route@6:
    // smart_contracts/reference_account_app/contract.py:38
    // @abimethod
    txn OnCompletion
    !
    txn ApplicationID
    &&
    assert // OnCompletion must be NoOp && can only call when not creating
    b increment_my_counter

main_opt_in_route@5:
    // smart_contracts/reference_account_app/contract.py:29
    // @abimethod(allow_actions=["OptIn"])
    txn OnCompletion
    intc_0 // OptIn
    ==
    txn ApplicationID
    &&
    assert // OnCompletion must be OptIn && can only call when not creating
    b opt_in

main___algopy_default_create@8:
    txn OnCompletion
    !
    txn ApplicationID
    !
    &&
    return // on error: OnCompletion must be NoOp && can only call when creating


// smart_contracts.reference_account_app.contract.MyCounter.opt_in[routing]() -> void:
opt_in:
    // smart_contracts/reference_account_app/contract.py:31
    // self.my_counter[Txn.sender] = UInt64(0)
    txn Sender
    bytec_0 // "my_counter"
    intc_1 // 0
    app_local_put
    // smart_contracts/reference_account_app/contract.py:29
    // @abimethod(allow_actions=["OptIn"])
    intc_0 // 1
    return


// smart_contracts.reference_account_app.contract.MyCounter.increment_my_counter[routing]() -> void:
increment_my_counter:
    // smart_contracts/reference_account_app/contract.py:40
    // assert Txn.sender.is_opted_in(Global.current_application_id)
    txn Sender
    global CurrentApplicationID
    app_opted_in
    assert
    // smart_contracts/reference_account_app/contract.py:42
    // self.my_counter[Txn.sender] += 1
    txn Sender
    dup
    intc_1 // 0
    bytec_0 // "my_counter"
    app_local_get_ex
    assert // check self.my_counter exists for account
    intc_0 // 1
    +
    bytec_0 // "my_counter"
    swap
    app_local_put
    // smart_contracts/reference_account_app/contract.py:43
    // return self.my_counter[Txn.sender]
    txn Sender
    intc_1 // 0
    bytec_0 // "my_counter"
    app_local_get_ex
    assert // check self.my_counter exists for account
    // smart_contracts/reference_account_app/contract.py:38
    // @abimethod
    itob
    pushbytes 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return
