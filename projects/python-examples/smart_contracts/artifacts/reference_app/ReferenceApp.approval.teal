#pragma version 11
#pragma typetrack false

// algopy.arc4.ARC4Contract.approval_program() -> uint64:
main:
    intcblock 6 0 1
    bytecblock 0x151f7c75 0x4a325901
    // smart_contracts/reference_app/contract.py:31
    // class ReferenceApp(ARC4Contract):
    txn NumAppArgs
    bz main___algopy_default_create@9
    txn OnCompletion
    !
    assert // OnCompletion must be NoOp
    txn ApplicationID
    assert
    pushbytess 0xd06846a9 0xa1f6b235 // method "increment_via_inner()uint64", method "increment_via_inner_with_arg(uint64)uint64"
    txna ApplicationArgs 0
    match increment_via_inner increment_via_inner_with_arg
    err

main___algopy_default_create@9:
    txn OnCompletion
    !
    txn ApplicationID
    !
    &&
    return // on error: OnCompletion must be NoOp && can only call when creating


// smart_contracts.reference_app.contract.ReferenceApp.increment_via_inner[routing]() -> void:
increment_via_inner:
    // smart_contracts/reference_app/contract.py:41-45
    // counter_result, call_txn = arc4.abi_call(
    //     Counter.increment,
    //     fee=0,
    //     app_id=app,
    // )
    itxn_begin
    // smart_contracts/reference_app/contract.py:39
    // app = Application(1717)  # Replace with your application id
    pushint 1717 // 1717
    itxn_field ApplicationID
    // smart_contracts/reference_app/contract.py:41-45
    // counter_result, call_txn = arc4.abi_call(
    //     Counter.increment,
    //     fee=0,
    //     app_id=app,
    // )
    bytec_1 // method "increment()uint64"
    itxn_field ApplicationArgs
    intc_0 // appl
    itxn_field TypeEnum
    // smart_contracts/reference_app/contract.py:43
    // fee=0,
    intc_1 // 0
    itxn_field Fee
    // smart_contracts/reference_app/contract.py:41-45
    // counter_result, call_txn = arc4.abi_call(
    //     Counter.increment,
    //     fee=0,
    //     app_id=app,
    // )
    itxn_submit
    itxn LastLog
    dup
    extract 4 0
    swap
    extract 0 4
    bytec_0 // 0x151f7c75
    ==
    assert // application log value is not the result of an ABI return
    // smart_contracts/reference_app/contract.py:37
    // @abimethod
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_2 // 1
    return


// smart_contracts.reference_app.contract.ReferenceApp.increment_via_inner_with_arg[routing]() -> void:
increment_via_inner_with_arg:
    // smart_contracts/reference_app/contract.py:54
    // @abimethod
    txna ApplicationArgs 1
    btoi
    // smart_contracts/reference_app/contract.py:56-57
    // # Call the increment method on the provided Counter application
    // counter_result, call_txn = arc4.abi_call(Counter.increment, fee=0, app_id=app)
    itxn_begin
    itxn_field ApplicationID
    bytec_1 // method "increment()uint64"
    itxn_field ApplicationArgs
    intc_0 // appl
    itxn_field TypeEnum
    intc_1 // 0
    itxn_field Fee
    itxn_submit
    itxn LastLog
    dup
    extract 4 0
    swap
    extract 0 4
    bytec_0 // 0x151f7c75
    ==
    assert // application log value is not the result of an ABI return
    // smart_contracts/reference_app/contract.py:54
    // @abimethod
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_2 // 1
    return
