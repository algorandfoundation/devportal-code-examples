#pragma version 11
#pragma typetrack false

// algopy.arc4.ARC4Contract.approval_program() -> uint64:
main:
    intcblock 1 0 400 2500
    bytecblock "counter" "key_length" "box_mbr" 0x151f7c75 "value_length" "box_size"
    txn ApplicationID
    bnz main_after_if_else@2
    // smart_contracts/reference_app_box/contract.py:18-19
    // # Define constants for box storage in global state
    // self.key_length = GlobalState(
    bytec_1 // "key_length"
    // smart_contracts/reference_app_box/contract.py:20
    // UInt64(COUNTER_BOX_KEY_LENGTH)
    pushint 51 // 51
    // smart_contracts/reference_app_box/contract.py:18-21
    // # Define constants for box storage in global state
    // self.key_length = GlobalState(
    //     UInt64(COUNTER_BOX_KEY_LENGTH)
    // )  # Account address (32 bytes) + key prefix overhead (19 bytes)
    app_global_put
    // smart_contracts/reference_app_box/contract.py:22
    // self.value_length = GlobalState(
    bytec 4 // "value_length"
    // smart_contracts/reference_app_box/contract.py:23
    // UInt64(COUNTER_BOX_VALUE_LENGTH)
    pushint 8 // 8
    // smart_contracts/reference_app_box/contract.py:22-24
    // self.value_length = GlobalState(
    //     UInt64(COUNTER_BOX_VALUE_LENGTH)
    // )  # uint64 (8 bytes)
    app_global_put

main_after_if_else@2:
    // smart_contracts/reference_app_box/contract.py:16
    // class ReferenceAppBox(ARC4Contract):
    txn OnCompletion
    !
    assert // OnCompletion must be NoOp
    txn ApplicationID
    bz main_create_NoOp@12
    pushbytess 0x035c8f99 0xc415992d 0xe0778501 0x3356861d 0x1a3ea0e9 0x059b2740 // method "increment_box_counter(pay)uint64", method "get_box_counter()uint64", method "get_box_counter_for_account(address)uint64", method "get_box_mbr()uint64", method "get_box_configuration()(uint64,uint64,uint64,uint64)", method "update_box_configuration(uint64,uint64)void"
    txna ApplicationArgs 0
    match increment_box_counter get_box_counter get_box_counter_for_account get_box_mbr get_box_configuration update_box_configuration
    err

main_create_NoOp@12:
    // smart_contracts/reference_app_box/contract.py:16
    // class ReferenceAppBox(ARC4Contract):
    pushbytes 0x4c5c61ba // method "create()void"
    txna ApplicationArgs 0
    match create
    err


// smart_contracts.reference_app_box.contract.ReferenceAppBox.create[routing]() -> void:
create:
    // smart_contracts/reference_app_box/contract.py:33
    // self.box_size.value = self.key_length.value + self.value_length.value
    intc_1 // 0
    bytec_1 // "key_length"
    app_global_get_ex
    assert // check self.key_length exists
    intc_1 // 0
    bytec 4 // "value_length"
    app_global_get_ex
    assert // check self.value_length exists
    +
    bytec 5 // "box_size"
    dig 1
    app_global_put
    // smart_contracts/reference_app_box/contract.py:34-36
    // self.box_mbr.value = UInt64(2_500) + self.box_size.value * UInt64(
    //     400
    // )  # Base MBR + (size * per-byte cost)
    intc_2 // 400
    *
    // smart_contracts/reference_app_box/contract.py:34
    // self.box_mbr.value = UInt64(2_500) + self.box_size.value * UInt64(
    intc_3 // 2500
    // smart_contracts/reference_app_box/contract.py:34-36
    // self.box_mbr.value = UInt64(2_500) + self.box_size.value * UInt64(
    //     400
    // )  # Base MBR + (size * per-byte cost)
    +
    // smart_contracts/reference_app_box/contract.py:34
    // self.box_mbr.value = UInt64(2_500) + self.box_size.value * UInt64(
    bytec_2 // "box_mbr"
    // smart_contracts/reference_app_box/contract.py:34-36
    // self.box_mbr.value = UInt64(2_500) + self.box_size.value * UInt64(
    //     400
    // )  # Base MBR + (size * per-byte cost)
    swap
    app_global_put
    // smart_contracts/reference_app_box/contract.py:31
    // @abimethod(create="require")
    intc_0 // 1
    return


// smart_contracts.reference_app_box.contract.ReferenceAppBox.increment_box_counter[routing]() -> void:
increment_box_counter:
    // smart_contracts/reference_app_box/contract.py:45
    // @abimethod
    txn GroupIndex
    intc_0 // 1
    -
    dup
    gtxns TypeEnum
    intc_0 // pay
    ==
    assert // transaction type is pay
    // smart_contracts/reference_app_box/contract.py:47-48
    // # Verify the payment covers the MBR cost and is sent to the contract
    // assert pay_mbr.amount == self.box_mbr.value, "Payment must cover the box MBR"
    dup
    gtxns Amount
    intc_1 // 0
    bytec_2 // "box_mbr"
    app_global_get_ex
    assert // check self.box_mbr exists
    ==
    assert // Payment must cover the box MBR
    // smart_contracts/reference_app_box/contract.py:50
    // pay_mbr.receiver == Global.current_application_address
    gtxns Receiver
    global CurrentApplicationAddress
    ==
    // smart_contracts/reference_app_box/contract.py:49-51
    // assert (
    //     pay_mbr.receiver == Global.current_application_address
    // ), "Payment must be to the contract"
    assert // Payment must be to the contract
    // smart_contracts/reference_app_box/contract.py:53
    // counter, has_counter = self.account_box_counter.maybe(Txn.sender)
    bytec_0 // "counter"
    txn Sender
    concat
    box_len
    bury 1
    // smart_contracts/reference_app_box/contract.py:55
    // if has_counter:
    bz increment_box_counter_else_body@3
    // smart_contracts/reference_app_box/contract.py:56
    // self.account_box_counter[Txn.sender] += 1
    bytec_0 // "counter"
    txn Sender
    concat
    dup
    box_get
    assert // check self.account_box_counter entry exists
    btoi
    intc_0 // 1
    +
    itob
    box_put
    // smart_contracts/reference_app_box/contract.py:57
    // return self.account_box_counter[Txn.sender]
    bytec_0 // "counter"
    txn Sender
    concat
    box_get
    assert // check self.account_box_counter entry exists
    btoi

increment_box_counter_after_inlined_smart_contracts.reference_app_box.contract.ReferenceAppBox.increment_box_counter@4:
    // smart_contracts/reference_app_box/contract.py:45
    // @abimethod
    itob
    bytec_3 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return

increment_box_counter_else_body@3:
    // smart_contracts/reference_app_box/contract.py:59
    // self.account_box_counter[Txn.sender] = UInt64(1)
    bytec_0 // "counter"
    txn Sender
    concat
    intc_0 // 1
    itob
    box_put
    // smart_contracts/reference_app_box/contract.py:60
    // return UInt64(1)
    intc_0 // 1
    // smart_contracts/reference_app_box/contract.py:45
    // @abimethod
    b increment_box_counter_after_inlined_smart_contracts.reference_app_box.contract.ReferenceAppBox.increment_box_counter@4


// smart_contracts.reference_app_box.contract.ReferenceAppBox.get_box_counter[routing]() -> void:
get_box_counter:
    // smart_contracts/reference_app_box/contract.py:69
    // counter, has_counter = self.account_box_counter.maybe(Txn.sender)
    bytec_0 // "counter"
    txn Sender
    concat
    box_get
    swap
    btoi
    swap
    // smart_contracts/reference_app_box/contract.py:70
    // if has_counter:
    bz get_box_counter_after_if_else@3
    dup

get_box_counter_after_inlined_smart_contracts.reference_app_box.contract.ReferenceAppBox.get_box_counter@4:
    // smart_contracts/reference_app_box/contract.py:67
    // @abimethod(readonly=True)
    itob
    bytec_3 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return

get_box_counter_after_if_else@3:
    // smart_contracts/reference_app_box/contract.py:72
    // return UInt64(0)
    intc_1 // 0
    // smart_contracts/reference_app_box/contract.py:67
    // @abimethod(readonly=True)
    b get_box_counter_after_inlined_smart_contracts.reference_app_box.contract.ReferenceAppBox.get_box_counter@4


// smart_contracts.reference_app_box.contract.ReferenceAppBox.get_box_counter_for_account[routing]() -> void:
get_box_counter_for_account:
    // smart_contracts/reference_app_box/contract.py:82
    // counter, has_counter = self.account_box_counter.maybe(account)
    bytec_0 // "counter"
    // smart_contracts/reference_app_box/contract.py:80
    // @abimethod(readonly=True)
    txna ApplicationArgs 1
    // smart_contracts/reference_app_box/contract.py:82
    // counter, has_counter = self.account_box_counter.maybe(account)
    concat
    box_get
    swap
    btoi
    swap
    // smart_contracts/reference_app_box/contract.py:83
    // if has_counter:
    bz get_box_counter_for_account_after_if_else@3
    dup

get_box_counter_for_account_after_inlined_smart_contracts.reference_app_box.contract.ReferenceAppBox.get_box_counter_for_account@4:
    // smart_contracts/reference_app_box/contract.py:80
    // @abimethod(readonly=True)
    itob
    bytec_3 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return

get_box_counter_for_account_after_if_else@3:
    // smart_contracts/reference_app_box/contract.py:85
    // return UInt64(0)
    intc_1 // 0
    // smart_contracts/reference_app_box/contract.py:80
    // @abimethod(readonly=True)
    b get_box_counter_for_account_after_inlined_smart_contracts.reference_app_box.contract.ReferenceAppBox.get_box_counter_for_account@4


// smart_contracts.reference_app_box.contract.ReferenceAppBox.get_box_mbr[routing]() -> void:
get_box_mbr:
    // smart_contracts/reference_app_box/contract.py:94
    // return self.box_mbr.value
    intc_1 // 0
    bytec_2 // "box_mbr"
    app_global_get_ex
    assert // check self.box_mbr exists
    // smart_contracts/reference_app_box/contract.py:92
    // @abimethod(readonly=True)
    itob
    bytec_3 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return


// smart_contracts.reference_app_box.contract.ReferenceAppBox.get_box_configuration[routing]() -> void:
get_box_configuration:
    // smart_contracts/reference_app_box/contract.py:104
    // self.key_length.value,
    intc_1 // 0
    bytec_1 // "key_length"
    app_global_get_ex
    assert // check self.key_length exists
    // smart_contracts/reference_app_box/contract.py:105
    // self.value_length.value,
    intc_1 // 0
    bytec 4 // "value_length"
    app_global_get_ex
    assert // check self.value_length exists
    // smart_contracts/reference_app_box/contract.py:106
    // self.box_size.value,
    intc_1 // 0
    bytec 5 // "box_size"
    app_global_get_ex
    assert // check self.box_size exists
    // smart_contracts/reference_app_box/contract.py:107
    // self.box_mbr.value,
    intc_1 // 0
    bytec_2 // "box_mbr"
    app_global_get_ex
    assert // check self.box_mbr exists
    // smart_contracts/reference_app_box/contract.py:101
    // @abimethod(readonly=True)
    uncover 3
    itob
    uncover 3
    itob
    concat
    uncover 2
    itob
    concat
    swap
    itob
    concat
    bytec_3 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return


// smart_contracts.reference_app_box.contract.ReferenceAppBox.update_box_configuration[routing]() -> void:
update_box_configuration:
    // smart_contracts/reference_app_box/contract.py:116
    // @abimethod
    txna ApplicationArgs 1
    btoi
    txna ApplicationArgs 2
    btoi
    // smart_contracts/reference_app_box/contract.py:120
    // self.key_length.value = new_key_length
    bytec_1 // "key_length"
    uncover 2
    app_global_put
    // smart_contracts/reference_app_box/contract.py:121
    // self.value_length.value = new_value_length
    bytec 4 // "value_length"
    dig 1
    app_global_put
    // smart_contracts/reference_app_box/contract.py:123-124
    // # Recalculate derived values
    // self.box_size.value = self.key_length.value + self.value_length.value
    intc_1 // 0
    bytec_1 // "key_length"
    app_global_get_ex
    assert // check self.key_length exists
    +
    bytec 5 // "box_size"
    dig 1
    app_global_put
    // smart_contracts/reference_app_box/contract.py:125
    // self.box_mbr.value = UInt64(2_500) + self.box_size.value * UInt64(400)
    intc_2 // 400
    *
    intc_3 // 2500
    +
    bytec_2 // "box_mbr"
    swap
    app_global_put
    // smart_contracts/reference_app_box/contract.py:116
    // @abimethod
    intc_0 // 1
    return
